# REST API 심화 프로젝트 보고서

**학번**: [학번 입력 필요]  
**이름**: 권수현  
**GitHub 저장소**: https://github.com/osoohynn/redo-api  
**GitHub 사용자명**: osoohynn  

---

## 목차
1. [프로젝트 개요](#1-프로젝트-개요)
2. [팀구성 및 개발 역할](#2-팀구성-및-개발-역할)
3. [기술 스택 및 개발환경](#3-기술-스택-및-개발환경)
4. [프로젝트 설계 및 구현](#4-프로젝트-설계-및-구현)
5. [트러블슈팅](#5-트러블슈팅)
6. [결론 및 향후 개선](#6-결론-및-향후-개선)

---

## 1. 프로젝트 개요

**프로젝트명**: redo-api
**프로젝트 목적**: 도서 리뷰 관리 시스템을 위한 REST API 개발

독서는 개인의 성장과 지식 습득에 중요한 활동이지만, 읽은 책에 대한 생각과 느낌을 체계적으로 기록하고 관리하기는 쉽지 않습니다. 또한 다른 독자들의 의견을 참고하여 다음에 읽을 책을 선택하고 싶어도 신뢰할 수 있는 리뷰를 찾기 어려운 경우가 많습니다.

본 프로젝트는 이러한 문제를 해결하기 위해 개발된 도서 리뷰 관리 시스템입니다. 사용자들이 읽은 책에 대한 리뷰를 작성하고 관리할 수 있는 플랫폼을 제공하여, 개인의 독서 기록을 체계적으로 남기고 다른 독자들과 독서 경험을 공유할 수 있도록 돕습니다. 회원 인증 시스템을 통해 개인별 리뷰 관리가 가능하며, 다양한 검색 기능으로 원하는 책이나 평점 기준에 맞는 리뷰를 쉽게 찾을 수 있습니다.

**핵심 가치**:
- 개인의 독서 기록을 체계적으로 관리하고 보존
- 독자 간 독서 경험 공유를 통한 커뮤니티 형성
- 책 선택 시 실제 독자의 의견을 참고할 수 있는 신뢰성 있는 정보 제공
- 평점과 리뷰를 통한 양질의 도서 추천 기반 마련

---

## 2. 팀구성 및 개발 역할

### 팀 구성
- **권수현** (본인): 프로젝트 초기 세팅, 공통 모듈 개발, 리뷰 쿼리 기능 개발
- **신지윤**: 리뷰 기본 CRUD 제작, validation 라이브러리 도입
- **이건희**: Spring Security 및 JWT 인증 개발, 리뷰 기능 인증 적용

### 개인 담당 도메인 및 주요 기능

만든 기능들:
- 회원가입/로그인 (JWT 토큰 사용)
- 책 리뷰 작성, 조회, 수정, 삭제
- 책 제목이나 평점으로 리뷰 검색
- 페이징으로 많은 데이터도 빠르게 불러오기

#### 프로젝트 초기 세팅
처음에 프로젝트를 만들 때 Spring Boot 3.5.8로 시작했습니다. Gradle로 라이브러리들을 관리하도록 설정하고, 패키지들을 auth, review, global로 나누어서 깔끔하게 정리했습니다. 데이터베이스는 H2를 써서 개발하기 편하게 했습니다.

#### 공통 모듈 개발
팀원들이 똑같은 코드를 반복해서 쓰지 않도록 공통으로 쓸 수 있는 클래스들을 만들었습니다.

**BaseEntity 클래스**를 만들어서 모든 테이블에 공통으로 들어가는 생성일시, 수정일시를 자동으로 관리하도록 했습니다.

**BaseResponse 클래스**는 API 응답을 통일된 형태로 보내주려고 만들었습니다. 성공하면 200, 생성하면 201 이런 식으로 상태코드도 정확하게 보내줍니다.

**QueryDSL 설정**도 했는데, 이건 복잡한 검색 기능을 만들 때 필요해서 미리 준비해놨습니다.

#### 리뷰 쿼리 기능 개발
**ReviewQueryRepository**를 만들어서 QueryDSL로 동적 쿼리를 구현했습니다. 책 제목으로 검색하거나, 평점 범위로 필터링하거나, 특정 사용자 리뷰만 보는 기능들을 넣었습니다. 페이징이랑 정렬도 같이 구현했습니다.

**ReviewQueryService**에서는 복잡한 쿼리 로직들을 처리합니다. 평점별로 보거나, 사용자별로 보거나, 책 제목으로 검색하는 기능들이 여기 있습니다. 높은 평점 리뷰만 따로 볼 수 있는 기능도 만들었습니다.

---

## 3. 기술 스택 및 개발환경

### Backend Framework
- **Spring Boot**: 3.5.8
- **Java**: 21
- **Spring Security**: JWT 기반 인증
- **Spring Data JPA**: 데이터 접근 계층

### Database
- **H2 Database**: 인메모리 데이터베이스 (개발/테스트용)
- **JPA/Hibernate**: ORM 프레임워크

### Query & Validation
- **QueryDSL**: 5.0.0 - 복잡한 동적 쿼리 작성
- **Spring Boot Validation**: 입력 데이터 검증

### Build Tool
- **Gradle**: 빌드 및 의존성 관리

### API Documentation
- **Swagger/OpenAPI**: 2.8.0 - API 문서 자동 생성

### 개발환경
- **IDE**: IntelliJ IDEA / VSCode
- **Version Control**: Git & GitHub
- **Server Port**: 8090

---

## 4. 프로젝트 설계 및 구현

### 아키텍처 설계
우리 프로젝트는 3계층 아키텍처로 만들었습니다:

1. **Presentation Layer (Controller)**
   - REST API 엔드포인트를 여기서 정의합니다
   - 요청이랑 응답을 처리하고 데이터도 검증합니다
   - HTTP 상태 코드도 관리합니다

2. **Business Layer (Service)**
   - 비즈니스 로직을 여기서 처리합니다
   - 트랜잭션 관리도 여기서 합니다
   - 도메인 규칙도 적용합니다

3. **Data Access Layer (Repository)**
   - 데이터베이스에 접근하는 계층입니다
   - 쿼리를 실행합니다
   - 데이터를 저장하고 가져옵니다

### 핵심 구현 내용

#### 1. 공통 모듈 구현
```java
// BaseEntity - 공통 속성 관리
@MappedSuperclass
@EntityListeners(AuditingEntityListener.class)
public abstract class BaseEntity {
    @CreatedDate
    @Column(nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @LastModifiedDate
    @Column(nullable = false)
    private LocalDateTime updatedAt;
}
```

#### 2. QueryDSL을 활용한 동적 쿼리 구현
```java
@Repository
public class ReviewQueryRepositoryImpl implements ReviewQueryRepository {
    private final JPAQueryFactory queryFactory;

    @Override
    public Page<ReviewEntity> searchReviews(String bookTitle, Integer minRating, 
                                             Integer maxRating, Long userId, Pageable pageable) {
        List<ReviewEntity> content = queryFactory
                .selectFrom(review)
                .where(
                        bookTitleContains(bookTitle),
                        ratingGoe(minRating),
                        ratingLoe(maxRating),
                        userIdEq(userId)
                )
                .orderBy(getOrderSpecifiers(pageable.getSort()))
                .offset(pageable.getOffset())
                .limit(pageable.getPageSize())
                .fetch();
        
        // 카운트 쿼리와 결합하여 Page 객체 반환
    }
}
```

#### 3. 서비스 계층 구현
```java
@Service
@Transactional(readOnly = true)
public class ReviewQueryService {
    private final ReviewQueryRepository reviewQueryRepository;

    public Page<ReviewResponse> searchReviews(String bookTitle, Integer minRating, 
                                               Integer maxRating, Long userId, Pageable pageable) {
        Page<ReviewEntity> reviews = reviewQueryRepository.searchReviews(
                bookTitle, minRating, maxRating, userId, pageable);
        
        return reviews.map(ReviewResponse::from);
    }
}
```

#### 4. REST API 설계
REST API 규칙에 맞게 만들었습니다:
- **HTTP 메서드 준수**: GET으로 조회, POST로 생성, PUT으로 수정, DELETE로 삭제
- **표준 상태 코드**: 200(성공), 201(생성됨), 204(삭제됨), 400(잘못된 요청), 401(인증 안됨), 403(권한 없음), 404(없음)
- **통일된 JSON 응답**: BaseResponse 클래스로 응답 형식을 통일했습니다

### JPA 엔티티 설계
```java
@Entity
@Table(name = "reviews")
public class ReviewEntity extends BaseEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotBlank(message = "책 제목은 필수입니다.")
    @Size(min = 1, max = 200)
    @Column(nullable = false, length = 200)
    private String bookTitle;
    
    // 추가 필드들...
}
```

---

## 5. 트러블슈팅

### 1. QueryDSL 설정할 때 문제 생김
**어떤 문제였는지**: QueryDSL을 쓰려고 하는데 Q클래스라는게 자동으로 안 만들어져서 에러가 났습니다.
```
Caused by: java.lang.ClassNotFoundException: com.lsk.redoapi.review.domain.entity.QReviewEntity
```

**어떻게 해결했는지**:
처음엔 뭐가 문제인지 몰라서 인터넷 찾아보니까 Gradle 설정을 제대로 안해서 그런거였습니다. build.gradle에 이것들을 추가했습니다:
```gradle
// QueryDSL
implementation 'com.querydsl:querydsl-jpa:5.0.0:jakarta'
annotationProcessor 'com.querydsl:querydsl-apt:5.0.0:jakarta'
annotationProcessor 'jakarta.annotation:jakarta.annotation-api'
annotationProcessor 'jakarta.persistence:jakarta.persistence-api'
```
그리고 IntelliJ에서 Annotation Processing을 켜주고, clean build를 다시 하니까 됐습니다.

**결과**: 이제 QueryDSL을 제대로 쓸 수 있게 됐습니다!

### 2. 페이징 성능 최적화
**문제**: 데이터가 많아지면 카운트 쿼리 때문에 느려지는 문제가 생겼습니다.

**해결 방법**:
PageableExecutionUtils를 써서 불필요한 카운트 쿼리를 안 하도록 만들었습니다:
```java
// PageableExecutionUtils를 사용하여 불필요한 카운트 쿼리 방지
return PageableExecutionUtils.getPage(content, pageable, countQuery::fetchOne);
```

### 3. 동적 정렬 조건 처리
**문제**: 사용자가 어떤 기준으로 정렬할지 선택할 수 있게 해야 했습니다.

**해결 과정**:
switch문으로 정렬 조건을 동적으로 처리했습니다:
```java
private OrderSpecifier<?>[] getOrderSpecifiers(Sort sort) {
    List<OrderSpecifier<?>> orders = new ArrayList<>();
    
    if (sort.isEmpty()) {
        orders.add(review.createdAt.desc());
        return orders.toArray(new OrderSpecifier[0]);
    }

    for (Sort.Order order : sort) {
        switch (order.getProperty()) {
            case "rating" -> orders.add(order.isAscending() ? 
                review.rating.asc() : review.rating.desc());
            case "bookTitle" -> orders.add(order.isAscending() ? 
                review.bookTitle.asc() : review.bookTitle.desc());
            // 추가 정렬 조건들...
        }
    }
    return orders.toArray(new OrderSpecifier[0]);
}
```

---

## 6. 결론 및 향후 개선

### 이번 프로젝트에서 얻은 것들
1. **3계층 구조로 깔끔하게 만들기**: Controller는 요청받고, Service는 로직 처리하고, Repository는 DB 접근하는 식으로 역할을 나눠서 코드가 정리됐습니다.
2. **QueryDSL 써보기**: 처음엔 어려웠는데 익숙해지니까 복잡한 검색 기능도 쉽게 만들 수 있었습니다.
3. **코드 재사용하기**: 공통으로 쓸 수 있는 클래스들을 만들어서 중복 코드가 줄었습니다.
4. **페이징 처리**: 데이터가 많아져도 느려지지 않도록 페이징을 구현했습니다.

### 새로 배운 기술들
- **QueryDSL**: 문자열로 쿼리 쓰는 것보다 안전하고, 오타나면 컴파일할 때 바로 알 수 있어서 좋았습니다.
- **Spring Data JPA**: 페이징이나 정렬 같은 기능들이 이미 다 만들어져 있어서 편했습니다.
- **아키텍처 설계**: 각 계층이 뭘 해야 하는지 확실히 나누는 방법을 배웠습니다.

### 향후 개선 계획
1. **테스트 코드 강화**
   - QueryDSL Repository 계층에 대한 테스트 추가하기
   - 복잡한 쿼리 조건들 테스트하기

2. **성능 최적화**
   - 쿼리 성능 모니터링 도구 넣기
   - 인덱스 최적화로 검색 빠르게 만들기

3. **기능 확장**
   - 전문 검색(Full-text Search) 기능 추가하기
   - 리뷰 추천 알고리즘 구현하기
   - 캐싱 전략 도입하기 (Redis)

4. **코드 품질 향상**
   - SonarQube로 코드 품질 관리하기
   - 예외 처리랑 로깅 더 세밀하게 개선하기

이번 프로젝트로 Spring Boot를 제대로 써보면서 많이 배웠습니다. 특히 QueryDSL은 처음 써봤는데 생각보다 유용해서 다음에도 쓸 것 같습니다. 팀 프로젝트라서 코드 스타일도 맞춰야 하고, 공통 모듈도 만들어야 해서 혼자 할 때보다 더 신경 쓸게 많았지만 그만큼 배운 것도 많았습니다.