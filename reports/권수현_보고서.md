# REST API 심화 프로젝트 보고서

**학번**: [학번 입력 필요]  
**이름**: 권수현  
**GitHub 저장소**: https://github.com/osoohynn/redo-api  
**GitHub 사용자명**: osoohynn  

---

## 목차
1. [프로젝트 개요](#1-프로젝트-개요)
2. [팀구성 및 개발 역할](#2-팀구성-및-개발-역할)
3. [기술 스택 및 개발환경](#3-기술-스택-및-개발환경)
4. [프로젝트 설계 및 구현](#4-프로젝트-설계-및-구현)
5. [트러블슈팅](#5-트러블슈팅)
6. [결론 및 향후 개선](#6-결론-및-향후-개선)

---

## 1. 프로젝트 개요

**프로젝트명**: redo-api  
**프로젝트 목적**: 도서 리뷰 관리 시스템을 위한 REST API 개발  

본 프로젝트는 사용자들이 도서에 대한 리뷰를 작성, 조회, 수정, 삭제할 수 있는 기능을 제공하는 REST API 시스템입니다. Spring Boot 기반으로 개발되었으며, JWT를 활용한 인증 시스템과 복잡한 쿼리 조건을 지원하는 검색 기능을 포함하고 있습니다.

주요 기능:
- 사용자 인증 및 권한 관리 (JWT 기반)
- 도서 리뷰 CRUD 작업
- 다양한 조건을 통한 리뷰 검색 및 필터링
- 페이징 처리를 통한 효율적인 데이터 조회

---

## 2. 팀구성 및 개발 역할

### 팀 구성
- **권수현** (본인): 프로젝트 초기 세팅, 공통 모듈 개발, 리뷰 쿼리 기능 개발
- **신지윤**: 리뷰 기본 CRUD 제작, validation 라이브러리 도입
- **이건희**: Spring Security 및 JWT 인증 개발, 리뷰 기능 인증 적용

### 개인 담당 도메인 및 주요 기능

#### 프로젝트 초기 세팅
- Spring Boot 3.5.8 프로젝트 구조 설계
- Gradle 의존성 관리 및 빌드 설정
- 패키지 구조 설계 (도메인별 계층 분리)
- H2 데이터베이스 및 JPA 환경 설정

#### 공통 모듈 개발
1. **BaseEntity 클래스**: 엔티티 공통 속성 관리
   ```java
   @MappedSuperclass
   @EntityListeners(AuditingEntityListener.class)
   public abstract class BaseEntity {
       @CreatedDate
       private LocalDateTime createdAt;
       
       @LastModifiedDate
       private LocalDateTime updatedAt;
   }
   ```

2. **BaseResponse 클래스**: API 응답 통일화
   ```java
   public static <T> ResponseEntity<BaseResponse<T>> ok(T data) {
       return response(HttpStatus.OK, "Success", data);
   }
   ```

3. **QueryDSL 설정**: 복잡한 쿼리 작성을 위한 환경 구성

#### 리뷰 쿼리 기능 개발
1. **ReviewQueryRepository 인터페이스 및 구현체**
   - QueryDSL을 활용한 동적 쿼리 구현
   - 다양한 검색 조건 지원 (책 제목, 평점 범위, 사용자 ID)
   - 페이징 및 정렬 기능 구현

2. **ReviewQueryService**: 복잡한 쿼리 로직을 담당하는 서비스 계층
   - 조건별 리뷰 검색 기능
   - 평점별, 사용자별, 책 제목별 필터링
   - 높은 평점 리뷰 조회 기능

---

## 3. 기술 스택 및 개발환경

### Backend Framework
- **Spring Boot**: 3.5.8
- **Java**: 21
- **Spring Security**: JWT 기반 인증
- **Spring Data JPA**: 데이터 접근 계층

### Database
- **H2 Database**: 인메모리 데이터베이스 (개발/테스트용)
- **JPA/Hibernate**: ORM 프레임워크

### Query & Validation
- **QueryDSL**: 5.0.0 - 복잡한 동적 쿼리 작성
- **Spring Boot Validation**: 입력 데이터 검증

### Build Tool
- **Gradle**: 빌드 및 의존성 관리

### API Documentation
- **Swagger/OpenAPI**: 2.8.0 - API 문서 자동 생성

### 개발환경
- **IDE**: IntelliJ IDEA / VSCode
- **Version Control**: Git & GitHub
- **Server Port**: 8090

---

## 4. 프로젝트 설계 및 구현

### 아키텍처 설계
본 프로젝트는 **3계층 아키텍처(3-Tier Architecture)**를 기반으로 설계되었습니다:

1. **Presentation Layer (Controller)**
   - REST API 엔드포인트 정의
   - 요청/응답 처리 및 데이터 검증
   - HTTP 상태 코드 관리

2. **Business Layer (Service)**
   - 비즈니스 로직 처리
   - 트랜잭션 관리
   - 도메인 규칙 적용

3. **Data Access Layer (Repository)**
   - 데이터베이스 접근
   - 쿼리 수행
   - 데이터 영속성 관리

### 핵심 구현 내용

#### 1. 공통 모듈 구현
```java
// BaseEntity - 공통 속성 관리
@MappedSuperclass
@EntityListeners(AuditingEntityListener.class)
public abstract class BaseEntity {
    @CreatedDate
    @Column(nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @LastModifiedDate
    @Column(nullable = false)
    private LocalDateTime updatedAt;
}
```

#### 2. QueryDSL을 활용한 동적 쿼리 구현
```java
@Repository
public class ReviewQueryRepositoryImpl implements ReviewQueryRepository {
    private final JPAQueryFactory queryFactory;

    @Override
    public Page<ReviewEntity> searchReviews(String bookTitle, Integer minRating, 
                                             Integer maxRating, Long userId, Pageable pageable) {
        List<ReviewEntity> content = queryFactory
                .selectFrom(review)
                .where(
                        bookTitleContains(bookTitle),
                        ratingGoe(minRating),
                        ratingLoe(maxRating),
                        userIdEq(userId)
                )
                .orderBy(getOrderSpecifiers(pageable.getSort()))
                .offset(pageable.getOffset())
                .limit(pageable.getPageSize())
                .fetch();
        
        // 카운트 쿼리와 결합하여 Page 객체 반환
    }
}
```

#### 3. 서비스 계층 구현
```java
@Service
@Transactional(readOnly = true)
public class ReviewQueryService {
    private final ReviewQueryRepository reviewQueryRepository;

    public Page<ReviewResponse> searchReviews(String bookTitle, Integer minRating, 
                                               Integer maxRating, Long userId, Pageable pageable) {
        Page<ReviewEntity> reviews = reviewQueryRepository.searchReviews(
                bookTitle, minRating, maxRating, userId, pageable);
        
        return reviews.map(ReviewResponse::from);
    }
}
```

#### 4. REST API 설계
- **HTTP 메서드 준수**: GET, POST, PUT, DELETE
- **표준 상태 코드**: 200, 201, 204, 400, 401, 403, 404
- **통일된 JSON 응답**: BaseResponse 클래스 활용

### JPA 엔티티 설계
```java
@Entity
@Table(name = "reviews")
public class ReviewEntity extends BaseEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotBlank(message = "책 제목은 필수입니다.")
    @Size(min = 1, max = 200)
    @Column(nullable = false, length = 200)
    private String bookTitle;
    
    // 추가 필드들...
}
```

---

## 5. 트러블슈팅

### 1. QueryDSL 설정 이슈
**문제**: QueryDSL Q클래스 자동 생성이 되지 않는 문제
```
Caused by: java.lang.ClassNotFoundException: com.lsk.redoapi.review.domain.entity.QReviewEntity
```

**해결 과정**:
1. Gradle 빌드 스크립트 QueryDSL 설정 확인
2. annotationProcessor 의존성 추가
```gradle
// QueryDSL
implementation 'com.querydsl:querydsl-jpa:5.0.0:jakarta'
annotationProcessor 'com.querydsl:querydsl-apt:5.0.0:jakarta'
annotationProcessor 'jakarta.annotation:jakarta.annotation-api'
annotationProcessor 'jakarta.persistence:jakarta.persistence-api'
```
3. IDE에서 Annotation Processing 활성화
4. `./gradlew clean build` 실행하여 Q클래스 재생성

**결과**: Q클래스가 성공적으로 생성되어 QueryDSL 사용 가능

### 2. 페이징 성능 최적화
**문제**: 대용량 데이터에서 카운트 쿼리 성능 저하

**해결 방법**:
```java
// PageableExecutionUtils를 사용하여 불필요한 카운트 쿼리 방지
return PageableExecutionUtils.getPage(content, pageable, countQuery::fetchOne);
```

### 3. 동적 정렬 조건 처리
**문제**: 사용자가 입력한 정렬 조건을 동적으로 처리해야 하는 요구사항

**해결 과정**:
```java
private OrderSpecifier<?>[] getOrderSpecifiers(Sort sort) {
    List<OrderSpecifier<?>> orders = new ArrayList<>();
    
    if (sort.isEmpty()) {
        orders.add(review.createdAt.desc());
        return orders.toArray(new OrderSpecifier[0]);
    }

    for (Sort.Order order : sort) {
        switch (order.getProperty()) {
            case "rating" -> orders.add(order.isAscending() ? 
                review.rating.asc() : review.rating.desc());
            case "bookTitle" -> orders.add(order.isAscending() ? 
                review.bookTitle.asc() : review.bookTitle.desc());
            // 추가 정렬 조건들...
        }
    }
    return orders.toArray(new OrderSpecifier[0]);
}
```

---

## 6. 결론 및 향후 개선

### 프로젝트 성과
1. **완전한 3계층 아키텍처 구현**: Controller-Service-Repository 계층 간 역할이 명확히 분리됨
2. **QueryDSL 활용**: 복잡한 동적 쿼리를 안전하고 효율적으로 구현
3. **공통 모듈 구현**: BaseEntity, BaseResponse 등을 통한 코드 재사용성 향상
4. **페이징 처리**: 대용량 데이터 처리를 위한 효율적인 페이징 구현

### 학습한 기술
- **QueryDSL**: 컴파일 타임에 쿼리 오류를 발견할 수 있는 안전한 쿼리 작성 방법
- **Spring Data JPA**: 페이징, 정렬 등 고급 기능 활용
- **아키텍처 설계**: 계층별 역할 분리와 의존성 관리

### 향후 개선 계획
1. **테스트 코드 강화**
   - QueryDSL Repository 계층에 대한 통합 테스트 추가
   - 복잡한 쿼리 조건에 대한 테스트 케이스 확장

2. **성능 최적화**
   - 쿼리 성능 모니터링 도구 도입
   - 인덱스 최적화를 통한 검색 성능 향상

3. **기능 확장**
   - 전문 검색(Full-text Search) 기능 추가
   - 리뷰 추천 알고리즘 구현
   - 캐싱 전략 도입 (Redis)

4. **코드 품질 향상**
   - SonarQube를 통한 코드 품질 관리
   - 더 세밀한 예외 처리 및 로깅 개선

본 프로젝트를 통해 실무에서 사용되는 최신 Spring 기술들을 체계적으로 학습하고 적용할 수 있었으며, 특히 QueryDSL을 활용한 복잡한 쿼리 구현과 효과적인 아키텍처 설계 경험을 얻을 수 있었습니다.