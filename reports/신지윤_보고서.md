# REST API 심화 프로젝트 보고서

**학번**: [학번 입력 필요]  
**이름**: 신지윤  
**GitHub 저장소**: https://github.com/osoohynn/redo-api  
**GitHub 사용자명**: [GitHub 사용자명 입력 필요]  

---

## 목차
1. [프로젝트 개요](#1-프로젝트-개요)
2. [팀구성 및 개발 역할](#2-팀구성-및-개발-역할)
3. [기술 스택 및 개발환경](#3-기술-스택-및-개발환경)
4. [프로젝트 설계 및 구현](#4-프로젝트-설계-및-구현)
5. [트러블슈팅](#5-트러블슈팅)
6. [결론 및 향후 개선](#6-결론-및-향후-개선)

---

## 1. 프로젝트 개요

**프로젝트명**: redo-api
**프로젝트 목적**: 도서 리뷰 관리 시스템을 위한 REST API 개발

독서는 개인의 성장과 지식 습득에 중요한 활동이지만, 읽은 책에 대한 생각과 느낌을 체계적으로 기록하고 관리하기는 쉽지 않습니다. 또한 다른 독자들의 의견을 참고하여 다음에 읽을 책을 선택하고 싶어도 신뢰할 수 있는 리뷰를 찾기 어려운 경우가 많습니다.

본 프로젝트는 이러한 문제를 해결하기 위해 개발된 도서 리뷰 관리 시스템입니다. 사용자들이 읽은 책에 대한 리뷰를 작성하고 관리할 수 있는 플랫폼을 제공하여, 개인의 독서 기록을 체계적으로 남기고 다른 독자들과 독서 경험을 공유할 수 있도록 돕습니다. 회원 인증 시스템을 통해 개인별 리뷰 관리가 가능하며, 다양한 검색 기능으로 원하는 책이나 평점 기준에 맞는 리뷰를 쉽게 찾을 수 있습니다.

**핵심 가치**:
- 개인의 독서 기록을 체계적으로 관리하고 보존
- 독자 간 독서 경험 공유를 통한 커뮤니티 형성
- 책 선택 시 실제 독자의 의견을 참고할 수 있는 신뢰성 있는 정보 제공
- 평점과 리뷰를 통한 양질의 도서 추천 기반 마련

---

## 2. 팀구성 및 개발 역할

### 팀 구성
- **권수현**: 프로젝트 초기 세팅, 공통 모듈 개발, 리뷰 쿼리 기능 개발
- **신지윤** (본인): 리뷰 기본 CRUD 제작, validation 라이브러리 도입
- **이건희**: Spring Security 및 JWT 인증 개발, 리뷰 기능 인증 적용

### 개인 담당 도메인 및 주요 기능

#### 리뷰 CRUD 기능 만들기
리뷰에 대한 모든 기본 작업을 만들었습니다.

만든 기능들:
- 책 리뷰 작성, 조회, 수정, 삭제 기능
- 자기가 쓴 리뷰만 수정/삭제할 수 있게 하기
- 잘못된 데이터를 차단하는 검증 시스템
- REST API 규칙에 맞게 API 만들기

**ReviewController**에서는 이런 API들을 만들었습니다:
- POST `/api/reviews` - 새 리뷰 작성
- GET `/api/reviews/{id}` - 리뷰 하나만 보기
- GET `/api/reviews` - 리뷰 리스트 전부 보기
- PUT `/api/reviews/{id}` - 리뷰 수정하기
- DELETE `/api/reviews/{id}` - 리뷰 삭제하기

**ReviewService**에서는 실제 로직을 처리했습니다. 다른 사람이 내 리뷰를 수정하거나 삭제하지 못하도록 소유권 검사도 넣었습니다.

**ReviewRepository**는 JPA Repository를 써서 데이터베이스 작업들을 처리했습니다.

#### 입력 데이터 검증 기능 만들기
사용자가 이상한 데이터를 넣어도 오류가 나지 않도록 validation 라이브러리를 도입했습니다.

**엔티티에서 검증**: ReviewEntity 클래스에 @NotBlank, @Size 같은 어노테이션을 붙여서 잘못된 데이터가 저장되는 걸 방지했습니다.

**DTO에서도 검증**: API로 들어오는 데이터도 미리 검사하도록 Request DTO에 검증 규칙들을 넣었습니다.

**한국어 오류 메시지**: 영어로 나오는 오류 메시지 대신 "책 제목은 필수입니다" 이런 식으로 한국어로 메시지를 만들었습니다.

---

## 3. 기술 스택 및 개발환경

### Backend Framework
- **Spring Boot**: 3.5.8
- **Java**: 21
- **Spring Data JPA**: 데이터 접근 계층
- **Spring Boot Validation**: 입력 데이터 검증

### Database
- **H2 Database**: 인메모리 데이터베이스 (개발/테스트용)
- **JPA/Hibernate**: ORM 프레임워크

### Validation
- **Jakarta Validation API**: Bean Validation 2.0 스펙
- **Hibernate Validator**: 검증 구현체

### Build Tool
- **Gradle**: 빌드 및 의존성 관리

### 개발환경
- **IDE**: IntelliJ IDEA / VSCode
- **Version Control**: Git & GitHub
- **Database Console**: H2 Console (개발용)

---

## 4. 프로젝트 설계 및 구현

### 핵심 구현 내용

#### 1. 리뷰 엔티티 설계 및 검증 규칙
```java
@Entity
@Table(name = "reviews")
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class ReviewEntity extends BaseEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotBlank(message = "책 제목은 필수입니다.")
    @Size(min = 1, max = 200, message = "책 제목은 1자 이상 200자 이하여야 합니다.")
    @Column(nullable = false, length = 200)
    private String bookTitle;

    @NotBlank(message = "리뷰 내용은 필수입니다.")
    @Size(min = 1, max = 5000, message = "리뷰 내용은 1자 이상 5000자 이하여야 합니다.")
    @Column(nullable = false, columnDefinition = "TEXT")
    private String content;

    @Min(value = 1, message = "평점은 1 이상이어야 합니다.")
    @Max(value = 5, message = "평점은 5 이하여야 합니다.")
    @Column(nullable = false)
    private int rating;

    @Column(name = "user_id", nullable = false)
    private Long userId;
}
```

#### 2. Request DTO 검증 구현
```java
@Getter
public class CreateReviewRequest {
    @NotBlank(message = "책 제목은 필수입니다.")
    @Size(min = 1, max = 200, message = "책 제목은 1자 이상 200자 이하여야 합니다.")
    private String bookTitle;

    @NotBlank(message = "리뷰 내용은 필수입니다.")
    @Size(min = 1, max = 5000, message = "리뷰 내용은 1자 이상 5000자 이하여야 합니다.")
    private String content;

    @NotNull(message = "평점은 필수입니다.")
    @Min(value = 1, message = "평점은 1 이상이어야 합니다.")
    @Max(value = 5, message = "평점은 5 이하여야 합니다.")
    private Integer rating;
}
```

#### 3. REST Controller 구현
```java
@RestController
@RequestMapping("/api/reviews")
@RequiredArgsConstructor
public class ReviewController {
    private final ReviewService reviewService;

    @PostMapping
    public ResponseEntity<BaseResponse<ReviewResponse>> createReview(@Valid @RequestBody CreateReviewRequest request) {
        ReviewResponse response = reviewService.createReview(request);
        return BaseResponse.created(response);
    }

    @GetMapping("/{id}")
    public ResponseEntity<BaseResponse<ReviewResponse>> getReview(@PathVariable Long id) {
        ReviewResponse response = reviewService.getReviewById(id);
        return BaseResponse.ok(response);
    }

    @GetMapping
    public ResponseEntity<BaseResponse<List<ReviewResponse>>> getAllReviews() {
        List<ReviewResponse> responses = reviewService.getAllReviews();
        return BaseResponse.ok(responses);
    }

    @PutMapping("/{id}")
    public ResponseEntity<BaseResponse<ReviewResponse>> updateReview(
            @PathVariable Long id, @Valid @RequestBody UpdateReviewRequest request) {
        ReviewResponse response = reviewService.updateReview(id, request);
        return BaseResponse.ok(response);
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<BaseResponse<Void>> deleteReview(@PathVariable Long id) {
        reviewService.deleteReview(id);
        return BaseResponse.noContent();
    }
}
```

#### 4. Service 계층 비즈니스 로직
```java
@Service
@RequiredArgsConstructor
@Transactional(readOnly = true)
public class ReviewService {
    private final ReviewRepository reviewRepository;

    @Transactional
    public ReviewResponse createReview(CreateReviewRequest request) {
        Long userId = getCurrentUserId();

        ReviewEntity review = ReviewEntity.builder()
                .bookTitle(request.getBookTitle())
                .content(request.getContent())
                .rating(request.getRating())
                .userId(userId)
                .build();

        ReviewEntity savedReview = reviewRepository.save(review);
        return ReviewResponse.from(savedReview);
    }

    @Transactional
    public ReviewResponse updateReview(Long id, UpdateReviewRequest request) {
        Long userId = getCurrentUserId();
        
        ReviewEntity review = reviewRepository.findById(id)
                .orElseThrow(() -> new CustomException(ErrorCode.REVIEW_NOT_FOUND));

        if (review.isNotOwner(userId)) {
            throw new CustomException(ErrorCode.FORBIDDEN);
        }

        review.update(request.getBookTitle(), request.getContent(), request.getRating());
        return ReviewResponse.from(review);
    }
}
```

### 검증 시스템 특징
1. **다층 검증 구조**: Entity, DTO 레벨에서 이중 검증
2. **사용자 친화적 메시지**: 한국어 기반 명확한 오류 메시지
3. **비즈니스 규칙 적용**: 평점 1-5 범위, 글자 수 제한 등
4. **Null 안전성**: @NotBlank, @NotNull 등을 통한 Null 체크

---

## 5. 트러블슈팅

### 1. Validation이 제대로 안 되는 문제
**어떤 문제였는지**: @Valid 어노테이션을 붙여놨는데도 입력 검증이 안 됐습니다. 비어있는 데이터나 이상한 데이터가 그대로 Service까지 넘어와서 문제가 생겼습니다.

**어떻게 해결했는지**:
처음에는 뭐가 문제인지 몰라서 한참 헤맸는데, Spring Boot에 validation 라이브러리를 추가해야 한다는 걸 알았습니다:
```gradle
implementation 'org.springframework.boot:spring-boot-starter-validation'
```
그리고 Controller에서 @Valid를 제대로 붙여야 하고:
```java
public ResponseEntity<BaseResponse<ReviewResponse>> createReview(@Valid @RequestBody CreateReviewRequest request)
```
예외 처리도 제대로 해야 한다는 걸 배웠습니다.

**결과**: 이제 잘못된 데이터는 미리 차단되고 사용자에게 친절한 오류 메시지가 갑니다.

### 2. 엔티티 업데이트 메서드 설계
**문제**: 불변성을 유지하면서 엔티티 속성을 안전하게 업데이트하는 방법

**해결 방법**:
```java
public class ReviewEntity {
    public void update(String bookTitle, String content, int rating) {
        this.bookTitle = bookTitle;
        this.content = content;
        this.rating = rating;
    }

    public boolean isNotOwner(Long userId) {
        return !this.userId.equals(userId);
    }
}
```

### 3. 검증 메시지 국제화 이슈
**문제**: 다양한 검증 실패 상황에 대한 일관성 있는 메시지 제공

**해결 과정**:
```java
// 각 검증 어노테이션에 명확한 메시지 정의
@Size(min = 1, max = 200, message = "책 제목은 1자 이상 200자 이하여야 합니다.")
@Min(value = 1, message = "평점은 1 이상이어야 합니다.")
@Max(value = 5, message = "평점은 5 이하여야 합니다.")
```

### 4. 리뷰 소유권 검증 로직
**문제**: 사용자가 자신이 작성하지 않은 리뷰를 수정/삭제하려 할 때의 처리

**해결 방법**:
```java
if (review.isNotOwner(userId)) {
    throw new CustomException(ErrorCode.FORBIDDEN);
}
```

### 테스트 코드 구현

#### 1. ReviewControllerTest
MockMvc를 사용하여 컨트롤러 계층의 API 요청/응답을 검증하는 테스트를 작성했습니다.

**테스트 항목**:

1. **리뷰 생성 성공 테스트** (`createReview_success`)
   - POST 요청으로 리뷰가 정상적으로 생성되는지 확인
   - HTTP 상태 코드 201(Created) 반환 확인
   - 응답 데이터가 요청 데이터와 일치하는지 검증

```java
@Test
@DisplayName("POST /api/reviews - 리뷰 생성 성공")
void createReview_success() throws Exception {
    // given
    CreateReviewRequest request = new CreateReviewRequest();
    ReflectionTestUtils.setField(request, "bookTitle", "테스트 책");
    ReflectionTestUtils.setField(request, "content", "테스트 내용");
    ReflectionTestUtils.setField(request, "rating", 5);

    ReviewResponse response = ReviewResponse.builder()
            .id(1L)
            .bookTitle("테스트 책")
            .content("테스트 내용")
            .rating(5)
            .createdAt(LocalDateTime.now())
            .updatedAt(LocalDateTime.now())
            .build();

    given(reviewService.createReview(any(CreateReviewRequest.class))).willReturn(response);

    // when & then
    mockMvc.perform(post("/api/reviews")
                    .contentType(MediaType.APPLICATION_JSON)
                    .content(objectMapper.writeValueAsString(request)))
            .andExpect(status().isCreated())
            .andExpect(jsonPath("$.data.bookTitle").value("테스트 책"))
            .andExpect(jsonPath("$.data.rating").value(5));
}
```

2. **리뷰 생성 실패 - Validation 테스트** (`createReview_validationFail`)
   - 빈 책 제목으로 요청 시 @Valid 검증이 작동하는지 확인
   - HTTP 상태 코드 400(Bad Request) 반환 확인

```java
@Test
@DisplayName("POST /api/reviews - 실패 (@Valid 검증 실패 - 빈 제목)")
void createReview_validationFail() throws Exception {
    // given - bookTitle이 빈 문자열
    CreateReviewRequest request = new CreateReviewRequest();
    ReflectionTestUtils.setField(request, "bookTitle", "");
    ReflectionTestUtils.setField(request, "content", "테스트 내용");
    ReflectionTestUtils.setField(request, "rating", 5);

    // when & then
    mockMvc.perform(post("/api/reviews")
                    .contentType(MediaType.APPLICATION_JSON)
                    .content(objectMapper.writeValueAsString(request)))
            .andExpect(status().isBadRequest());
}
```

3. **리뷰 조회 성공 테스트** (`getReview_success`)
   - GET 요청으로 특정 리뷰를 정상적으로 조회하는지 확인
   - HTTP 상태 코드 200(OK) 반환 확인

```java
@Test
@DisplayName("GET /api/reviews/{id} - 리뷰 조회 성공")
void getReview_success() throws Exception {
    // given
    Long reviewId = 1L;
    ReviewResponse response = ReviewResponse.builder()
            .id(reviewId)
            .bookTitle("테스트 책")
            .content("테스트 내용")
            .rating(5)
            .createdAt(LocalDateTime.now())
            .updatedAt(LocalDateTime.now())
            .build();

    given(reviewService.getReviewById(reviewId)).willReturn(response);

    // when & then
    mockMvc.perform(get("/api/reviews/{id}", reviewId))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.data.id").value(reviewId))
            .andExpect(jsonPath("$.data.bookTitle").value("테스트 책"));
}
```

4. **리뷰 조회 실패 테스트** (`getReview_notFound`)
   - 존재하지 않는 리뷰 조회 시 404 에러 반환 확인
   - CustomException 처리가 올바른지 검증

```java
@Test
@DisplayName("GET /api/reviews/{id} - 실패 (존재하지 않는 리뷰)")
void getReview_notFound() throws Exception {
    // given
    Long reviewId = 999L;
    given(reviewService.getReviewById(reviewId))
            .willThrow(new CustomException(ErrorCode.REVIEW_NOT_FOUND));

    // when & then
    mockMvc.perform(get("/api/reviews/{id}", reviewId))
            .andExpect(status().isNotFound());
}
```

5. **리뷰 수정 성공 테스트** (`updateReview_success`)
   - PUT 요청으로 리뷰가 정상적으로 수정되는지 확인
   - 수정된 데이터가 응답에 반영되는지 검증

```java
@Test
@DisplayName("PUT /api/reviews/{id} - 리뷰 수정 성공")
void updateReview_success() throws Exception {
    // given
    Long reviewId = 1L;
    UpdateReviewRequest request = new UpdateReviewRequest();
    ReflectionTestUtils.setField(request, "bookTitle", "수정된 책");
    ReflectionTestUtils.setField(request, "content", "수정된 내용");
    ReflectionTestUtils.setField(request, "rating", 4);

    ReviewResponse response = ReviewResponse.builder()
            .id(reviewId)
            .bookTitle("수정된 책")
            .content("수정된 내용")
            .rating(4)
            .createdAt(LocalDateTime.now())
            .updatedAt(LocalDateTime.now())
            .build();

    given(reviewService.updateReview(eq(reviewId), any(UpdateReviewRequest.class)))
            .willReturn(response);

    // when & then
    mockMvc.perform(put("/api/reviews/{id}", reviewId)
                    .contentType(MediaType.APPLICATION_JSON)
                    .content(objectMapper.writeValueAsString(request)))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.data.bookTitle").value("수정된 책"))
            .andExpect(jsonPath("$.data.rating").value(4));
}
```

6. **리뷰 수정 실패 - Validation 테스트** (`updateReview_validationFail`)
   - 잘못된 평점(1~5 범위 초과)으로 요청 시 검증 실패 확인
   - @Min, @Max 어노테이션의 동작 검증

```java
@Test
@DisplayName("PUT /api/reviews/{id} - 실패 (@Valid 검증 실패 - 잘못된 평점)")
void updateReview_validationFail() throws Exception {
    // given - rating이 범위 밖 (6점)
    Long reviewId = 1L;
    UpdateReviewRequest request = new UpdateReviewRequest();
    ReflectionTestUtils.setField(request, "bookTitle", "수정된 책");
    ReflectionTestUtils.setField(request, "content", "수정된 내용");
    ReflectionTestUtils.setField(request, "rating", 6); // 1~5 범위 초과

    // when & then
    mockMvc.perform(put("/api/reviews/{id}", reviewId)
                    .contentType(MediaType.APPLICATION_JSON)
                    .content(objectMapper.writeValueAsString(request)))
            .andExpect(status().isBadRequest());
}
```

**테스트 전략**:
- Mockito를 사용하여 Service 계층을 Mock으로 대체
- MockMvc를 통한 실제 HTTP 요청/응답 시뮬레이션
- GlobalExceptionHandler와 통합하여 예외 처리 검증
- ReflectionTestUtils로 private 필드에 테스트 데이터 주입
- BDD 스타일 (given-when-then) 테스트 작성

**테스트 결과**:
- 총 6개의 테스트 케이스 작성
- CRUD 및 Validation 기능 완벽 검증
- 모든 테스트 통과 확인

#### 2. ReviewRepositoryTest
JPA Repository의 CRUD 기본 동작을 검증하는 테스트를 작성했습니다.

**테스트 항목**:

1. **리뷰 저장 성공 테스트** (`save_success`)

```java
@Test
@DisplayName("리뷰 저장 - 성공")
void save_success() {
    // given
    ReviewEntity review = ReviewEntity.builder()
            .bookTitle("테스트 책")
            .content("테스트 내용")
            .rating(5)
            .userId(1L)
            .build();

    // when
    ReviewEntity savedReview = reviewRepository.save(review);

    // then
    assertThat(savedReview).isNotNull();
    assertThat(savedReview.getId()).isNotNull();
    assertThat(savedReview.getBookTitle()).isEqualTo("테스트 책");
}
```

2. **리뷰 조회 성공 테스트** (`findById_success`)

```java
@Test
@DisplayName("리뷰 조회 by ID - 성공")
void findById_success() {
    // given
    ReviewEntity review = ReviewEntity.builder()
            .bookTitle("자바의 정석")
            .content("좋은 책")
            .rating(5)
            .userId(1L)
            .build();
    ReviewEntity savedReview = reviewRepository.save(review);

    // when
    Optional<ReviewEntity> foundReview = reviewRepository.findById(savedReview.getId());

    // then
    assertThat(foundReview).isPresent();
    assertThat(foundReview.get().getBookTitle()).isEqualTo("자바의 정석");
}
```

3. **리뷰 조회 실패 테스트** (`findById_notFound`)

```java
@Test
@DisplayName("리뷰 조회 by ID - 실패 (존재하지 않음)")
void findById_notFound() {
    // given
    Long nonExistentId = 999L;

    // when
    Optional<ReviewEntity> foundReview = reviewRepository.findById(nonExistentId);

    // then
    assertThat(foundReview).isEmpty();
}
```

4. **전체 리뷰 조회 테스트** (`findAll_success`)

```java
@Test
@DisplayName("전체 리뷰 조회 - 성공")
void findAll_success() {
    // given
    reviewRepository.save(ReviewEntity.builder()
            .bookTitle("책1").content("내용1").rating(5).userId(1L).build());
    reviewRepository.save(ReviewEntity.builder()
            .bookTitle("책2").content("내용2").rating(4).userId(1L).build());
    reviewRepository.save(ReviewEntity.builder()
            .bookTitle("책3").content("내용3").rating(3).userId(1L).build());

    // when
    List<ReviewEntity> reviews = reviewRepository.findAll();

    // then
    assertThat(reviews).hasSize(3);
    assertThat(reviews).extracting("bookTitle")
            .contains("책1", "책2", "책3");
}
```

5. **리뷰 삭제 테스트** (`delete_success`)

```java
@Test
@DisplayName("리뷰 삭제 - 성공")
void delete_success() {
    // given
    ReviewEntity review = reviewRepository.save(ReviewEntity.builder()
            .bookTitle("삭제할 책").content("내용").rating(5).userId(1L).build());
    Long savedId = review.getId();

    // when
    reviewRepository.deleteById(savedId);

    // then
    assertThat(reviewRepository.findById(savedId)).isEmpty();
}
```

6. **필수 필드 누락 테스트** (3개)
   - JPA의 @Column(nullable=false) 제약 조건 검증

```java
@Test
@DisplayName("리뷰 저장 - 실패 (필수 필드 누락 - bookTitle)")
void save_fail_missingBookTitle() {
    // given - bookTitle이 null
    ReviewEntity review = ReviewEntity.builder()
            .bookTitle(null) // 필수 필드 누락
            .content("테스트 내용")
            .rating(5)
            .userId(1L)
            .build();

    // when & then
    try {
        reviewRepository.saveAndFlush(review);
        assertThat(true).isFalse(); // 예외가 발생해야 함
    } catch (Exception e) {
        assertThat(e).isNotNull();
    }
}

@Test
@DisplayName("리뷰 저장 - 실패 (필수 필드 누락 - content)")
void save_fail_missingContent() {
    // given - content가 null
    ReviewEntity review = ReviewEntity.builder()
            .bookTitle("테스트 책")
            .content(null) // 필수 필드 누락
            .rating(5)
            .userId(1L)
            .build();

    // when & then
    try {
        reviewRepository.saveAndFlush(review);
        assertThat(true).isFalse(); // 예외가 발생해야 함
    } catch (Exception e) {
        assertThat(e).isNotNull();
    }
}

@Test
@DisplayName("리뷰 저장 - 실패 (필수 필드 누락 - userId)")
void save_fail_missingUserId() {
    // given - userId가 null
    ReviewEntity review = ReviewEntity.builder()
            .bookTitle("테스트 책")
            .content("테스트 내용")
            .rating(5)
            .userId(null) // 필수 필드 누락
            .build();

    // when & then
    try {
        reviewRepository.saveAndFlush(review);
        assertThat(true).isFalse(); // 예외가 발생해야 함
    } catch (Exception e) {
        assertThat(e).isNotNull();
    }
}
```

**테스트 전략**:
- `@DataJpaTest`로 JPA 관련 컴포넌트만 로드
- 실제 H2 데이터베이스를 사용한 통합 테스트
- AssertJ의 fluent API로 가독성 높은 검증
- 각 테스트는 트랜잭션이 롤백되어 독립적으로 실행

**테스트 결과**:
- 총 8개의 테스트 케이스 작성
- 기본 CRUD 및 제약 조건 검증 완료
- 모든 테스트 통과 확인

---

## 6. 결론 및 향후 개선

### 이번 프로젝트에서 얻은 것들
1. **CRUD 기능 완성**: 리뷰에 대한 모든 기본 작업들을 API로 만들었습니다.
2. **데이터 검증 시스템**: 이상한 데이터가 들어오는 걸 미리 차단할 수 있게 됐습니다.
3. **REST API 규칙 지키기**: POST는 생성, GET은 조회 이런 식으로 제대로 만들었습니다.
4. **코드 정리**: Controller는 요청만 받고, Service에서 로직 처리하도록 깔끔하게 나누었습니다.

### 새로 배운 기술들
- **Bean Validation**: @NotBlank, @Size 같은 어노테이션만 붙여도 자동으로 검증되는 게 신기했습니다.
- **Spring MVC**: @RestController, @RequestMapping 사용법을 제대로 배웠습니다.
- **JPA 엔티티**: 데이터베이스 테이블과 연결되는 방법이나 엔티티 라이프사이클 개념을 배웠습니다.
- **예외 처리**: 전역으로 예외를 처리하는 방법과 커스텀 예외 만드는 법을 배웠습니다.

### 향후 개선 계획
1. **테스트 코드 확장**
   - ReviewService에 대한 단위 테스트 추가하기
   - 권한 검증 로직에 대한 테스트 추가하기
   - 통합 테스트(Controller + Service + Repository) 작성하기

2. **검증 로직 고도화**
   - 커스텀 Validator 구현하기 (중복 리뷰 방지 등)
   - 교차 필드 검증 (Cross-field Validation) 추가하기
   - 조건부 검증 로직 추가하기

3. **API 성능 최적화**
   - 페이징 처리 개선하기
   - N+1 쿼리 문제 해결하기
   - 캐싱 전략 도입하기

4. **사용자 경험 개선**
   - API 문서 자동화하기 (Swagger)
   - 더 세밀한 오류 메시지 제공하기
   - API 버전 관리 체계 구축하기

이번 프로젝트로 Spring Boot를 제대로 써보면서 많이 배웠습니다. 특히 validation 기능이 생각보다 강력하고 유용했습니다. REST API를 제대로 만드는 법도 배웠고, 좋은 API를 만들려면 사소한 것들까지 신경 써야 한다는 걸 느꼈습니다. 혼자 했다면 대충대충 만들었을 텐데, 팀 프로젝트라서 더 꼼꼼하게 할 수 있었습니다.