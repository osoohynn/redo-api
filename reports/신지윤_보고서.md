# REST API 심화 프로젝트 보고서

**학번**: [학번 입력 필요]  
**이름**: 신지윤  
**GitHub 저장소**: https://github.com/osoohynn/redo-api  
**GitHub 사용자명**: [GitHub 사용자명 입력 필요]  

---

## 목차
1. [프로젝트 개요](#1-프로젝트-개요)
2. [팀구성 및 개발 역할](#2-팀구성-및-개발-역할)
3. [기술 스택 및 개발환경](#3-기술-스택-및-개발환경)
4. [프로젝트 설계 및 구현](#4-프로젝트-설계-및-구현)
5. [트러블슈팅](#5-트러블슈팅)
6. [결론 및 향후 개선](#6-결론-및-향후-개선)

---

## 1. 프로젝트 개요

**프로젝트명**: redo-api  
**프로젝트 목적**: 도서 리뷰 관리 시스템을 위한 REST API 개발  

본 프로젝트는 사용자들이 도서에 대한 리뷰를 작성, 조회, 수정, 삭제할 수 있는 REST API 시스템입니다. 사용자 인증을 기반으로 안전하고 체계적인 리뷰 관리 기능을 제공하며, 엄격한 데이터 검증을 통해 신뢰성 있는 서비스를 구현했습니다.

주요 기능:
- 도서 리뷰 CRUD (Create, Read, Update, Delete) 작업
- 사용자 권한 기반 리뷰 소유권 관리
- 입력 데이터에 대한 포괄적인 검증 시스템
- RESTful API 설계 원칙 준수

---

## 2. 팀구성 및 개발 역할

### 팀 구성
- **권수현**: 프로젝트 초기 세팅, 공통 모듈 개발, 리뷰 쿼리 기능 개발
- **신지윤** (본인): 리뷰 기본 CRUD 제작, validation 라이브러리 도입
- **이건희**: Spring Security 및 JWT 인증 개발, 리뷰 기능 인증 적용

### 개인 담당 도메인 및 주요 기능

#### 리뷰 기본 CRUD 제작
1. **ReviewController**: REST API 엔드포인트 구현
   - POST `/api/reviews` - 리뷰 생성
   - GET `/api/reviews/{id}` - 단일 리뷰 조회
   - GET `/api/reviews` - 전체 리뷰 목록 조회
   - PUT `/api/reviews/{id}` - 리뷰 수정
   - DELETE `/api/reviews/{id}` - 리뷰 삭제

2. **ReviewService**: 비즈니스 로직 구현
   - 리뷰 생성/수정/삭제 로직
   - 리뷰 소유권 검증
   - 사용자 인증 정보 처리

3. **ReviewRepository**: 데이터 액세스 계층
   - JPA Repository 인터페이스 정의
   - 기본 CRUD 메서드 활용

#### Validation 라이브러리 도입 및 검증 시스템 구축
1. **엔티티 레벨 검증**: ReviewEntity 클래스에 검증 어노테이션 적용
2. **DTO 레벨 검증**: Request DTO 클래스에 상세한 검증 규칙 구현
3. **커스텀 검증 메시지**: 한국어 기반 사용자 친화적 오류 메시지 제공

---

## 3. 기술 스택 및 개발환경

### Backend Framework
- **Spring Boot**: 3.5.8
- **Java**: 21
- **Spring Data JPA**: 데이터 접근 계층
- **Spring Boot Validation**: 입력 데이터 검증

### Database
- **H2 Database**: 인메모리 데이터베이스 (개발/테스트용)
- **JPA/Hibernate**: ORM 프레임워크

### Validation
- **Jakarta Validation API**: Bean Validation 2.0 스펙
- **Hibernate Validator**: 검증 구현체

### Build Tool
- **Gradle**: 빌드 및 의존성 관리

### 개발환경
- **IDE**: IntelliJ IDEA / VSCode
- **Version Control**: Git & GitHub
- **Database Console**: H2 Console (개발용)

---

## 4. 프로젝트 설계 및 구현

### 핵심 구현 내용

#### 1. 리뷰 엔티티 설계 및 검증 규칙
```java
@Entity
@Table(name = "reviews")
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class ReviewEntity extends BaseEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotBlank(message = "책 제목은 필수입니다.")
    @Size(min = 1, max = 200, message = "책 제목은 1자 이상 200자 이하여야 합니다.")
    @Column(nullable = false, length = 200)
    private String bookTitle;

    @NotBlank(message = "리뷰 내용은 필수입니다.")
    @Size(min = 1, max = 5000, message = "리뷰 내용은 1자 이상 5000자 이하여야 합니다.")
    @Column(nullable = false, columnDefinition = "TEXT")
    private String content;

    @Min(value = 1, message = "평점은 1 이상이어야 합니다.")
    @Max(value = 5, message = "평점은 5 이하여야 합니다.")
    @Column(nullable = false)
    private int rating;

    @Column(name = "user_id", nullable = false)
    private Long userId;
}
```

#### 2. Request DTO 검증 구현
```java
@Getter
public class CreateReviewRequest {
    @NotBlank(message = "책 제목은 필수입니다.")
    @Size(min = 1, max = 200, message = "책 제목은 1자 이상 200자 이하여야 합니다.")
    private String bookTitle;

    @NotBlank(message = "리뷰 내용은 필수입니다.")
    @Size(min = 1, max = 5000, message = "리뷰 내용은 1자 이상 5000자 이하여야 합니다.")
    private String content;

    @NotNull(message = "평점은 필수입니다.")
    @Min(value = 1, message = "평점은 1 이상이어야 합니다.")
    @Max(value = 5, message = "평점은 5 이하여야 합니다.")
    private Integer rating;
}
```

#### 3. REST Controller 구현
```java
@RestController
@RequestMapping("/api/reviews")
@RequiredArgsConstructor
public class ReviewController {
    private final ReviewService reviewService;

    @PostMapping
    public ResponseEntity<BaseResponse<ReviewResponse>> createReview(@Valid @RequestBody CreateReviewRequest request) {
        ReviewResponse response = reviewService.createReview(request);
        return BaseResponse.created(response);
    }

    @GetMapping("/{id}")
    public ResponseEntity<BaseResponse<ReviewResponse>> getReview(@PathVariable Long id) {
        ReviewResponse response = reviewService.getReviewById(id);
        return BaseResponse.ok(response);
    }

    @GetMapping
    public ResponseEntity<BaseResponse<List<ReviewResponse>>> getAllReviews() {
        List<ReviewResponse> responses = reviewService.getAllReviews();
        return BaseResponse.ok(responses);
    }

    @PutMapping("/{id}")
    public ResponseEntity<BaseResponse<ReviewResponse>> updateReview(
            @PathVariable Long id, @Valid @RequestBody UpdateReviewRequest request) {
        ReviewResponse response = reviewService.updateReview(id, request);
        return BaseResponse.ok(response);
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<BaseResponse<Void>> deleteReview(@PathVariable Long id) {
        reviewService.deleteReview(id);
        return BaseResponse.noContent();
    }
}
```

#### 4. Service 계층 비즈니스 로직
```java
@Service
@RequiredArgsConstructor
@Transactional(readOnly = true)
public class ReviewService {
    private final ReviewRepository reviewRepository;

    @Transactional
    public ReviewResponse createReview(CreateReviewRequest request) {
        Long userId = getCurrentUserId();

        ReviewEntity review = ReviewEntity.builder()
                .bookTitle(request.getBookTitle())
                .content(request.getContent())
                .rating(request.getRating())
                .userId(userId)
                .build();

        ReviewEntity savedReview = reviewRepository.save(review);
        return ReviewResponse.from(savedReview);
    }

    @Transactional
    public ReviewResponse updateReview(Long id, UpdateReviewRequest request) {
        Long userId = getCurrentUserId();
        
        ReviewEntity review = reviewRepository.findById(id)
                .orElseThrow(() -> new CustomException(ErrorCode.REVIEW_NOT_FOUND));

        if (review.isNotOwner(userId)) {
            throw new CustomException(ErrorCode.FORBIDDEN);
        }

        review.update(request.getBookTitle(), request.getContent(), request.getRating());
        return ReviewResponse.from(review);
    }
}
```

### 검증 시스템 특징
1. **다층 검증 구조**: Entity, DTO 레벨에서 이중 검증
2. **사용자 친화적 메시지**: 한국어 기반 명확한 오류 메시지
3. **비즈니스 규칙 적용**: 평점 1-5 범위, 글자 수 제한 등
4. **Null 안전성**: @NotBlank, @NotNull 등을 통한 Null 체크

---

## 5. 트러블슈팅

### 1. Validation 어노테이션 동작 이슈
**문제**: @Valid 어노테이션이 Controller에서 동작하지 않는 문제
```
Request DTO의 검증 어노테이션이 무시되어 잘못된 데이터가 Service까지 전달됨
```

**해결 과정**:
1. Spring Boot Validation 의존성 확인
```gradle
implementation 'org.springframework.boot:spring-boot-starter-validation'
```
2. Controller 메서드 파라미터에 @Valid 어노테이션 추가
```java
public ResponseEntity<BaseResponse<ReviewResponse>> createReview(@Valid @RequestBody CreateReviewRequest request)
```
3. GlobalExceptionHandler에 MethodArgumentNotValidException 처리 추가

**결과**: 입력 데이터 검증이 정상적으로 동작하여 잘못된 데이터 차단

### 2. 엔티티 업데이트 메서드 설계
**문제**: 불변성을 유지하면서 엔티티 속성을 안전하게 업데이트하는 방법

**해결 방법**:
```java
public class ReviewEntity {
    public void update(String bookTitle, String content, int rating) {
        this.bookTitle = bookTitle;
        this.content = content;
        this.rating = rating;
    }

    public boolean isNotOwner(Long userId) {
        return !this.userId.equals(userId);
    }
}
```

### 3. 검증 메시지 국제화 이슈
**문제**: 다양한 검증 실패 상황에 대한 일관성 있는 메시지 제공

**해결 과정**:
```java
// 각 검증 어노테이션에 명확한 메시지 정의
@Size(min = 1, max = 200, message = "책 제목은 1자 이상 200자 이하여야 합니다.")
@Min(value = 1, message = "평점은 1 이상이어야 합니다.")
@Max(value = 5, message = "평점은 5 이하여야 합니다.")
```

### 4. 리뷰 소유권 검증 로직
**문제**: 사용자가 자신이 작성하지 않은 리뷰를 수정/삭제하려 할 때의 처리

**해결 방법**:
```java
if (review.isNotOwner(userId)) {
    throw new CustomException(ErrorCode.FORBIDDEN);
}
```

---

## 6. 결론 및 향후 개선

### 프로젝트 성과
1. **완전한 CRUD 시스템 구현**: 리뷰에 대한 모든 기본 작업을 REST API로 제공
2. **포괄적인 검증 시스템**: 다층 검증을 통한 데이터 무결성 확보
3. **RESTful API 설계**: HTTP 메서드와 상태 코드를 적절히 활용
4. **비즈니스 로직 분리**: Service 계층에서 도메인 규칙 처리

### 학습한 기술
- **Bean Validation**: Jakarta Validation API를 활용한 선언적 검증
- **Spring MVC**: @RestController, @RequestMapping 등 웹 계층 기술
- **JPA Entity Lifecycle**: 엔티티의 생성, 수정, 삭제 과정
- **Exception Handling**: 전역 예외 처리 및 커스텀 예외 정의

### 향후 개선 계획
1. **테스트 코드 확장**
   - ReviewController에 대한 MockMvc 테스트 작성
   - ReviewService에 대한 단위 테스트 추가
   - 다양한 검증 실패 시나리오에 대한 테스트

2. **검증 로직 고도화**
   - 커스텀 Validator 구현 (중복 리뷰 방지 등)
   - 교차 필드 검증 (Cross-field Validation)
   - 조건부 검증 로직 추가

3. **API 성능 최적화**
   - 페이징 처리 개선
   - N+1 쿼리 문제 해결
   - 캐싱 전략 도입

4. **사용자 경험 개선**
   - API 문서 자동화 (Swagger)
   - 더 세밀한 오류 메시지 제공
   - API 버전 관리 체계 구축

본 프로젝트를 통해 Spring Boot의 핵심 기능들을 실무 수준에서 활용해보고, 특히 데이터 검증과 REST API 설계에 대한 깊이 있는 이해를 얻을 수 있었습니다. 체계적인 검증 시스템 구축을 통해 안정적이고 신뢰할 수 있는 API를 개발하는 경험을 했습니다.