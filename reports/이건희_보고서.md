# REST API 심화 프로젝트 보고서

**학번**: [학번 입력 필요]  
**이름**: 이건희  
**GitHub 저장소**: https://github.com/osoohynn/redo-api  
**GitHub 사용자명**: [GitHub 사용자명 입력 필요]  

---

## 목차
1. [프로젝트 개요](#1-프로젝트-개요)
2. [팀구성 및 개발 역할](#2-팀구성-및-개발-역할)
3. [기술 스택 및 개발환경](#3-기술-스택-및-개발환경)
4. [프로젝트 설계 및 구현](#4-프로젝트-설계-및-구현)
5. [트러블슈팅](#5-트러블슈팅)
6. [결론 및 향후 개선](#6-결론-및-향후-개선)

---

## 1. 프로젝트 개요

**프로젝트명**: redo-api
**프로젝트 목적**: 도서 리뷰 관리 시스템을 위한 REST API 개발

본 프로젝트는 Spring Boot 3.5.8 기반의 도서 리뷰 관리 REST API 서버입니다. JWT 토큰 기반 인증/인가 시스템을 통해 사용자별 리뷰 작성 및 관리 기능을 제공하며, QueryDSL을 활용한 동적 쿼리로 다양한 검색 조건을 지원합니다. Jakarta Validation을 통한 입력 데이터 검증, Spring Security를 통한 보안 강화, 그리고 3계층 아키텍처(Presentation-Service-Repository)로 구조화된 확장 가능한 시스템입니다.

**주요 기능**:
- **회원 인증**: JWT 토큰 기반 회원가입 및 로그인 (`/api/auth`)
- **리뷰 CRUD**: 리뷰 생성, 조회, 수정, 삭제 기능 (`/api/reviews`)
- **고급 검색**: 책 제목, 평점 범위, 사용자별 리뷰 검색 및 페이징 처리 (`/api/reviews/search`)
- **데이터 검증**: Bean Validation을 통한 입력 데이터 검증 (책 제목 1-200자, 평점 1-5점 등)
- **권한 관리**: 작성자 본인만 리뷰 수정/삭제 가능

---

## 2. 팀구성 및 개발 역할

### 팀 구성
- **권수현**: 프로젝트 초기 세팅, 공통 모듈 개발, 리뷰 쿼리 기능 개발
- **신지윤**: 리뷰 기본 CRUD 제작, validation 라이브러리 도입
- **이건희** (본인): Spring Security 및 JWT 인증 개발, 리뷰 기능 인증 적용

### 개인 담당 도메인 및 주요 기능

만든 기능들:
- JWT 토큰으로 회원가입하고 로그인하기
- 로그인한 사람만 리뷰 쓰고 수정하고 삭제할 수 있게 하기
- 자기가 쓴 리뷰만 수정/삭제할 수 있도록 권한 관리
- 비밀번호를 암호화해서 안전하게 저장

#### Spring Security랑 JWT 인증 시스템 만들기
처음에 보안 관련된 거 하나도 몰라서 걱정했는데, 하나하나 만들어보니까 재밌었습니다.

**SecurityConfig**는 Spring Security 설정하는 곳입니다. 어떤 API는 로그인 안 해도 되고, 어떤 건 로그인 필수인지 정해줬습니다. 그리고 JWT 토큰 검사하는 필터도 여기서 넣어줬습니다.

**JwtUtil** 클래스에서는 JWT 토큰을 만들고 검증하는 작업을 했습니다. 토큰에 사용자 이름이랑 ID를 넣고, 만료 시간도 설정했습니다.

**JwtAuthenticationFilter**는 사용자가 API 요청할 때마다 토큰이 제대로 된 건지 확인합니다. 헤더에서 토큰을 꺼내서 검증하고, 문제없으면 그 사용자 정보를 저장해둡니다.

#### 사용자 인증 기능 만들기
**UserEntity**는 사용자 테이블입니다. 이름이랑 비밀번호 같은 기본 정보를 저장하는데, 비밀번호는 암호화해서 저장했습니다.

**AuthController**에서는 회원가입이랑 로그인 API를 만들었습니다:
- POST `/api/auth/signup` - 새로 가입하기
- POST `/api/auth/login` - 로그인하고 토큰 받기

**AuthService**에서 실제 로직을 처리했습니다. 회원가입할 때는 이미 있는 이름인지 확인하고, 로그인할 때는 비밀번호가 맞는지 확인해서 JWT 토큰을 만들어서 줍니다.

#### 리뷰 기능에 인증 붙이기
**ReviewService**에 인증 기능을 붙였습니다. 리뷰 작성, 수정, 삭제할 때마다 로그인한 사용자가 맞는지, 자기가 쓴 리뷰가 맞는지 확인하도록 만들었습니다. SecurityContext라는 곳에서 현재 로그인한 사용자 정보를 가져와서 검사했습니다.

---

## 3. 기술 스택 및 개발환경

### Security & Authentication
- **Spring Security**: 6.x (Spring Boot 3.5.8 기본 포함)
- **JWT (JSON Web Token)**: io.jsonwebtoken:jjwt-api:0.12.3
- **BCrypt**: 비밀번호 암호화

### Backend Framework
- **Spring Boot**: 3.5.8
- **Java**: 21
- **Spring Data JPA**: 데이터 접근 계층

### Database
- **H2 Database**: 인메모리 데이터베이스
- **JPA/Hibernate**: ORM 프레임워크

### Build Tool
- **Gradle**: 빌드 및 의존성 관리

### Development Tools
- **H2 Console**: 데이터베이스 관리 (개발용)
- **Spring Boot DevTools**: 개발 편의성

---

## 4. 프로젝트 설계 및 구현

### 보안 아키텍처 설계
JWT 토큰을 사용해서 세션 없이도 인증할 수 있게 만들었습니다.

**동작 방식**:
1. 사용자가 로그인하면 JWT 토큰을 줍니다.
2. 다음부터는 API 요청할 때 이 토큰을 헤더에 같이 보냅니다.
3. 서버에서 토큰이 제대로 된 건지 확인하고 요청을 처리합니다.

**권한 관리**:
- 회원가입, 로그인, H2 콘솔, API 문서는 누구나 볼 수 있습니다.
- 리뷰 관련 API는 반드시 로그인 필요합니다.

### 핵심 구현 내용

#### 1. JWT 유틸리티 클래스
JWT 토큰을 만들고 검증하는 기능을 모아놨습니다.
```java
@Component
public class JwtUtil {
    @Value("${jwt.secret}")
    private String secretKey;

    @Value("${jwt.expiration}")
    private Long expiration;

    public String generateToken(String username, Long userId) {
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + expiration);

        return Jwts.builder()
                .setSubject(username)
                .claim("userId", userId)
                .setIssuedAt(now)
                .setExpiration(expiryDate)
                .signWith(getSigningKey(), SignatureAlgorithm.HS512)
                .compact();
    }

    public boolean validateToken(String token) {
        try {
            Jwts.parserBuilder()
                .setSigningKey(getSigningKey())
                .build()
                .parseClaimsJws(token);
            return true;
        } catch (JwtException | IllegalArgumentException e) {
            return false;
        }
    }
}
```

#### 2. Spring Security 설정
어떤 URL은 로그인 없이 접근 가능하고, 어떤 건 로그인 필수인지 설정했습니다.
```java
@Configuration
@EnableWebSecurity
@RequiredArgsConstructor
public class SecurityConfig {
    private final JwtAuthenticationFilter jwtAuthenticationFilter;

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
                .csrf(AbstractHttpConfigurer::disable)
                .sessionManagement(session -> session
                        .sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers("/api/auth/**", "/h2-console/**").permitAll()
                        .requestMatchers(HttpMethod.GET, "/swagger-ui/**", "/v3/api-docs/**").permitAll()
                        .anyRequest().authenticated())
                .headers(headers -> headers
                        .frameOptions(frameOptions -> frameOptions.sameOrigin()))
                .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
```

#### 3. JWT 인증 필터
모든 요청마다 토큰을 검사하는 필터입니다.
```java
@Component
@RequiredArgsConstructor
public class JwtAuthenticationFilter extends OncePerRequestFilter {
    private final JwtUtil jwtUtil;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, 
                                   FilterChain filterChain) throws ServletException, IOException {
        String token = extractTokenFromRequest(request);

        if (token != null && jwtUtil.validateToken(token)) {
            String username = jwtUtil.getUsernameFromToken(token);
            Long userId = jwtUtil.getUserIdFromToken(token);

            UsernamePasswordAuthenticationToken authentication = 
                new UsernamePasswordAuthenticationToken(username, null, Collections.emptyList());
            authentication.setDetails(userId);
            
            SecurityContextHolder.getContext().setAuthentication(authentication);
        }

        filterChain.doFilter(request, response);
    }

    private String extractTokenFromRequest(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");
        if (bearerToken != null && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }
}
```

#### 4. 인증 서비스 구현
회원가입이랑 로그인 로직을 처리합니다.
```java
@Service
@RequiredArgsConstructor
@Transactional(readOnly = true)
public class AuthService {
    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;
    private final JwtUtil jwtUtil;

    @Transactional
    public AuthResponse signup(SignupRequest request) {
        if (userRepository.existsByUsername(request.getUsername())) {
            throw new CustomException(ErrorCode.DUPLICATE_USERNAME);
        }

        UserEntity user = UserEntity.builder()
                .username(request.getUsername())
                .password(passwordEncoder.encode(request.getPassword()))
                .build();

        UserEntity savedUser = userRepository.save(user);
        String token = jwtUtil.generateToken(savedUser.getUsername(), savedUser.getId());

        return AuthResponse.builder()
                .token(token)
                .username(savedUser.getUsername())
                .build();
    }

    public AuthResponse login(LoginRequest request) {
        UserEntity user = userRepository.findByUsername(request.getUsername())
                .orElseThrow(() -> new CustomException(ErrorCode.USER_NOT_FOUND));

        if (!passwordEncoder.matches(request.getPassword(), user.getPassword())) {
            throw new CustomException(ErrorCode.INVALID_PASSWORD);
        }

        String token = jwtUtil.generateToken(user.getUsername(), user.getId());

        return AuthResponse.builder()
                .token(token)
                .username(user.getUsername())
                .build();
    }
}
```

#### 5. 리뷰 서비스 인증 통합
리뷰 수정/삭제할 때 자기가 쓴 리뷰인지 확인합니다.
```java
@Service
@RequiredArgsConstructor
@Transactional(readOnly = true)
public class ReviewService {
    private final ReviewRepository reviewRepository;

    private Long getCurrentUserId() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication == null || !authentication.isAuthenticated()) {
            throw new CustomException(ErrorCode.UNAUTHORIZED);
        }
        return (Long) authentication.getDetails();
    }

    @Transactional
    public ReviewResponse updateReview(Long id, UpdateReviewRequest request) {
        Long userId = getCurrentUserId();

        ReviewEntity review = reviewRepository.findById(id)
                .orElseThrow(() -> new CustomException(ErrorCode.REVIEW_NOT_FOUND));

        if (review.isNotOwner(userId)) {
            throw new CustomException(ErrorCode.FORBIDDEN);
        }

        review.update(request.getBookTitle(), request.getContent(), request.getRating());
        return ReviewResponse.from(review);
    }
}
```

---

## 5. 트러블슈팅

### 1. JWT 토큰 파싱할 때 에러 나는 문제
**어떤 문제였는지**: JWT 토큰을 검증하는데 SignatureException이라는 에러가 났습니다.
```
io.jsonwebtoken.security.SignatureException: JWT signature does not match locally computed signature
```

**어떻게 해결했는지**:
처음에는 뭐가 문제인지 몰라서 구글 검색 엄청 했습니다. 알고보니 JWT Secret Key 설정이 잘못 됐더라고요.

application.yml 파일에 이렇게 설정했습니다:
```yaml
jwt:
  secret: YXNkZmFzZGZhc2RmYXNkZmFzZGZhc2RmYXNkZmFzZGZhc2RmYXNkZmFzZGZhc2RmYXNkZmFzZGZhc2Rm
  expiration: 86400000 # 24시간
```

그리고 Base64로 인코딩된 키를 바이트 배열로 변환해줘야 한다는 걸 알았습니다:
```java
private Key getSigningKey() {
    byte[] keyBytes = Decoders.BASE64.decode(secretKey);
    return Keys.hmacShaKeyFor(keyBytes);
}
```

**결과**: 이제 JWT 토큰이 제대로 만들어지고 검증도 잘 됩니다!

### 2. SecurityContext에서 사용자 정보 가져오는 방법
**문제**: Authentication 객체에 사용자 ID를 어떻게 넣고 빼야 할지 몰랐습니다.

**해결 방법**:
인증 필터에서 사용자 ID를 Details에 저장하고:
```java
UsernamePasswordAuthenticationToken authentication =
    new UsernamePasswordAuthenticationToken(username, null, Collections.emptyList());
authentication.setDetails(userId);
```

서비스에서 이렇게 꺼내 쓰면 됩니다:
```java
private Long getCurrentUserId() {
    Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
    return (Long) authentication.getDetails();
}
```

### 3. H2 콘솔 접근이 안 되는 문제
**문제**: Spring Security 설정 때문에 H2 콘솔에 들어갈 수가 없었습니다.

**해결 과정**:
H2 콘솔은 로그인 없이도 접근 가능하게 해주고, 프레임 옵션도 설정해줬습니다:
```java
.authorizeHttpRequests(auth -> auth
    .requestMatchers("/api/auth/**", "/h2-console/**").permitAll()
    // ...
)
.headers(headers -> headers
    .frameOptions(frameOptions -> frameOptions.sameOrigin()))
```

### 4. CORS랑 PreFlight 요청 처리
**문제**: 브라우저에서 OPTIONS 요청이 401 에러로 막히는 문제가 생겼습니다.

**해결 방법**:
OPTIONS 요청은 로그인 없이도 통과하도록 설정했습니다:
```java
.authorizeHttpRequests(auth -> auth
    .requestMatchers(HttpMethod.OPTIONS).permitAll()
    .requestMatchers("/api/auth/**").permitAll()
    // ...
)
```

### 5. 비밀번호 검증이 안 되는 문제
**문제**: 올바른 비밀번호를 입력해도 로그인이 안 되는 이상한 상황이 발생했습니다.

**해결 과정**:
BCrypt 해시 과정을 로그로 찍어보고, 평문 비밀번호랑 암호화된 비밀번호가 제대로 매칭되는지 테스트해봤습니다:
```java
if (!passwordEncoder.matches(request.getPassword(), user.getPassword())) {
    log.debug("Password mismatch for user: {}", request.getUsername());
    throw new CustomException(ErrorCode.INVALID_PASSWORD);
}
```
알고 보니 회원가입할 때 비밀번호 암호화를 안 한 데이터가 있어서 그랬더라고요.

---

## 6. 결론 및 향후 개선

### 이번 프로젝트에서 얻은 것들
1. **JWT 인증 시스템 완성**: 토큰 만들고 검증하는 전체 과정을 다 구현했습니다.
2. **Spring Security 사용**: 최신 버전인 6.x 버전으로 보안 설정하는 방법을 배웠습니다.
3. **세션 없는 구조**: 세션을 안 써서 서버를 여러 개 띄워도 문제없는 구조를 만들었습니다.
4. **권한 관리**: 자기가 쓴 리뷰만 수정하고 삭제할 수 있게 권한을 체크했습니다.

### 새로 배운 기술들
- **JWT (JSON Web Token)**: 토큰 기반 인증이 어떻게 동작하는지 이해했습니다.
- **Spring Security**: 필터 체인이랑 인증/인가가 뭔지 배웠습니다.
- **BCrypt**: 비밀번호를 안전하게 저장하는 방법을 배웠습니다.
- **SecurityContext**: 인증 정보를 스레드마다 관리하는 방법을 배웠습니다.

### 향후 개선 계획
1. **보안 강화**
   - Refresh Token을 만들어서 토큰 갱신 기능 추가
   - 로그인 시도 횟수를 제한해서 무작위 대입 공격 방지
   - 비밀번호 규칙을 더 강하게 (특수문자 포함, 최소 길이 등)

2. **테스트 코드 작성**
   - SecurityConfig에 대한 테스트
   - JWT 토큰 만들고 검증하는 부분 테스트
   - 인증이 필요한 API 엔드포인트 테스트

3. **인증 시스템 확장**
   - 구글이나 깃허브 같은 소셜 로그인 붙이기
   - 2단계 인증(MFA) 추가하기
   - 사용자 역할(Role) 기반으로 권한 나누기

4. **모니터링 및 로깅**
   - 로그인 시도랑 실패를 자세하게 로그로 남기기
   - 보안 관련 이벤트 모니터링
   - JWT 토큰 만료되고 갱신되는 거 추적하기

5. **성능 최적화**
   - JWT 토큰 캐싱해서 성능 높이기
   - 사용자 정보 캐싱으로 DB 접근 줄이기
   - 비동기 로깅으로 성능 영향 최소화하기

이번 프로젝트로 보안에 대해 많이 배웠습니다. JWT랑 Spring Security가 처음에는 어려웠는데, 하나하나 만들어보니까 이제 이해가 됐습니다. 특히 보안은 예전에 크게 신경쓰지 않았는데, 이번에 직접 구현해보니까 예전보다 훨씬 신경 쓰게 됐습니다. 토큰 기반 인증이 세션보다 어떤 점이 좋은지, 그리고 어떤 점을 조심해야 하는지도 알게 됐습니다.