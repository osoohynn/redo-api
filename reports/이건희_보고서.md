# REST API 심화 프로젝트 보고서

**학번**: [학번 입력 필요]  
**이름**: 이건희  
**GitHub 저장소**: https://github.com/osoohynn/redo-api  
**GitHub 사용자명**: [GitHub 사용자명 입력 필요]  

---

## 목차
1. [프로젝트 개요](#1-프로젝트-개요)
2. [팀구성 및 개발 역할](#2-팀구성-및-개발-역할)
3. [기술 스택 및 개발환경](#3-기술-스택-및-개발환경)
4. [프로젝트 설계 및 구현](#4-프로젝트-설계-및-구현)
5. [트러블슈팅](#5-트러블슈팅)
6. [결론 및 향후 개선](#6-결론-및-향후-개선)

---

## 1. 프로젝트 개요

**프로젝트명**: redo-api  
**프로젝트 목적**: 도서 리뷰 관리 시스템을 위한 보안이 강화된 REST API 개발  

본 프로젝트는 JWT(JSON Web Token) 기반의 인증 시스템을 통해 보안이 강화된 도서 리뷰 관리 REST API입니다. Spring Security를 활용하여 안전한 사용자 인증 및 권한 관리를 구현하였으며, 리뷰 기능에 사용자 인증을 적용하여 데이터 보안을 확보했습니다.

주요 기능:
- JWT 기반 사용자 인증 및 토큰 관리
- 사용자 회원가입 및 로그인 기능
- 인증된 사용자만 리뷰 작성/수정/삭제 가능
- 리뷰 소유권 검증을 통한 권한 관리
- 비밀번호 암호화 및 보안 정책 적용

---

## 2. 팀구성 및 개발 역할

### 팀 구성
- **권수현**: 프로젝트 초기 세팅, 공통 모듈 개발, 리뷰 쿼리 기능 개발
- **신지윤**: 리뷰 기본 CRUD 제작, validation 라이브러리 도입
- **이건희** (본인): Spring Security 및 JWT 인증 개발, 리뷰 기능 인증 적용

### 개인 담당 도메인 및 주요 기능

#### Spring Security 및 JWT 인증 시스템 구축
1. **SecurityConfig**: Spring Security 보안 설정
   - JWT 필터 체인 구성
   - 인증/비인증 엔드포인트 설정
   - 세션 정책 및 CORS 설정

2. **JwtUtil**: JWT 토큰 생성 및 검증
   - 액세스 토큰 생성 및 파싱
   - 토큰 유효성 검증
   - 사용자 정보 추출

3. **JwtAuthenticationFilter**: JWT 인증 필터
   - 요청 헤더에서 JWT 토큰 추출
   - 토큰 검증 및 인증 컨텍스트 설정

#### 사용자 인증 시스템 개발
1. **UserEntity**: 사용자 엔티티 설계
   - 사용자 기본 정보 관리
   - 비밀번호 암호화 저장

2. **AuthController**: 인증 API 엔드포인트
   - 회원가입 (POST /api/auth/signup)
   - 로그인 (POST /api/auth/login)

3. **AuthService**: 인증 비즈니스 로직
   - 사용자 등록 및 중복 검사
   - 로그인 검증 및 토큰 발급

#### 리뷰 기능에 인증 적용
1. **ReviewService 인증 통합**: 모든 리뷰 작업에 사용자 인증 적용
2. **권한 기반 접근 제어**: 리뷰 소유자만 수정/삭제 가능
3. **보안 컨텍스트 관리**: SecurityContextHolder를 통한 인증 정보 관리

---

## 3. 기술 스택 및 개발환경

### Security & Authentication
- **Spring Security**: 6.x (Spring Boot 3.5.8 기본 포함)
- **JWT (JSON Web Token)**: io.jsonwebtoken:jjwt-api:0.12.3
- **BCrypt**: 비밀번호 암호화

### Backend Framework
- **Spring Boot**: 3.5.8
- **Java**: 21
- **Spring Data JPA**: 데이터 접근 계층

### Database
- **H2 Database**: 인메모리 데이터베이스
- **JPA/Hibernate**: ORM 프레임워크

### Build Tool
- **Gradle**: 빌드 및 의존성 관리

### Development Tools
- **H2 Console**: 데이터베이스 관리 (개발용)
- **Spring Boot DevTools**: 개발 편의성

---

## 4. 프로젝트 설계 및 구현

### 보안 아키텍처 설계
본 프로젝트의 보안 시스템은 **JWT 기반 Stateless 인증**을 중심으로 설계되었습니다:

1. **인증 흐름**
   ```
   Client → Login Request → AuthController → AuthService → JWT Token Response
   Client → API Request + JWT Token → JwtAuthenticationFilter → SecurityContext → API Access
   ```

2. **권한 관리**
   - 공개 엔드포인트: 회원가입, 로그인, H2 콘솔, API 문서
   - 보호 엔드포인트: 모든 리뷰 관련 API

### 핵심 구현 내용

#### 1. JWT 유틸리티 클래스
```java
@Component
public class JwtUtil {
    @Value("${jwt.secret}")
    private String secretKey;

    @Value("${jwt.expiration}")
    private Long expiration;

    public String generateToken(String username, Long userId) {
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + expiration);

        return Jwts.builder()
                .setSubject(username)
                .claim("userId", userId)
                .setIssuedAt(now)
                .setExpiration(expiryDate)
                .signWith(getSigningKey(), SignatureAlgorithm.HS512)
                .compact();
    }

    public boolean validateToken(String token) {
        try {
            Jwts.parserBuilder()
                .setSigningKey(getSigningKey())
                .build()
                .parseClaimsJws(token);
            return true;
        } catch (JwtException | IllegalArgumentException e) {
            return false;
        }
    }
}
```

#### 2. Spring Security 설정
```java
@Configuration
@EnableWebSecurity
@RequiredArgsConstructor
public class SecurityConfig {
    private final JwtAuthenticationFilter jwtAuthenticationFilter;

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
                .csrf(AbstractHttpConfigurer::disable)
                .sessionManagement(session -> session
                        .sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers("/api/auth/**", "/h2-console/**").permitAll()
                        .requestMatchers(HttpMethod.GET, "/swagger-ui/**", "/v3/api-docs/**").permitAll()
                        .anyRequest().authenticated())
                .headers(headers -> headers
                        .frameOptions(frameOptions -> frameOptions.sameOrigin()))
                .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
```

#### 3. JWT 인증 필터
```java
@Component
@RequiredArgsConstructor
public class JwtAuthenticationFilter extends OncePerRequestFilter {
    private final JwtUtil jwtUtil;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, 
                                   FilterChain filterChain) throws ServletException, IOException {
        String token = extractTokenFromRequest(request);

        if (token != null && jwtUtil.validateToken(token)) {
            String username = jwtUtil.getUsernameFromToken(token);
            Long userId = jwtUtil.getUserIdFromToken(token);

            UsernamePasswordAuthenticationToken authentication = 
                new UsernamePasswordAuthenticationToken(username, null, Collections.emptyList());
            authentication.setDetails(userId);
            
            SecurityContextHolder.getContext().setAuthentication(authentication);
        }

        filterChain.doFilter(request, response);
    }

    private String extractTokenFromRequest(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");
        if (bearerToken != null && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }
}
```

#### 4. 인증 서비스 구현
```java
@Service
@RequiredArgsConstructor
@Transactional(readOnly = true)
public class AuthService {
    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;
    private final JwtUtil jwtUtil;

    @Transactional
    public AuthResponse signup(SignupRequest request) {
        if (userRepository.existsByUsername(request.getUsername())) {
            throw new CustomException(ErrorCode.DUPLICATE_USERNAME);
        }

        UserEntity user = UserEntity.builder()
                .username(request.getUsername())
                .password(passwordEncoder.encode(request.getPassword()))
                .build();

        UserEntity savedUser = userRepository.save(user);
        String token = jwtUtil.generateToken(savedUser.getUsername(), savedUser.getId());

        return AuthResponse.builder()
                .token(token)
                .username(savedUser.getUsername())
                .build();
    }

    public AuthResponse login(LoginRequest request) {
        UserEntity user = userRepository.findByUsername(request.getUsername())
                .orElseThrow(() -> new CustomException(ErrorCode.USER_NOT_FOUND));

        if (!passwordEncoder.matches(request.getPassword(), user.getPassword())) {
            throw new CustomException(ErrorCode.INVALID_PASSWORD);
        }

        String token = jwtUtil.generateToken(user.getUsername(), user.getId());

        return AuthResponse.builder()
                .token(token)
                .username(user.getUsername())
                .build();
    }
}
```

#### 5. 리뷰 서비스 인증 통합
```java
@Service
@RequiredArgsConstructor
@Transactional(readOnly = true)
public class ReviewService {
    private final ReviewRepository reviewRepository;

    private Long getCurrentUserId() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication == null || !authentication.isAuthenticated()) {
            throw new CustomException(ErrorCode.UNAUTHORIZED);
        }
        return (Long) authentication.getDetails();
    }

    @Transactional
    public ReviewResponse updateReview(Long id, UpdateReviewRequest request) {
        Long userId = getCurrentUserId();

        ReviewEntity review = reviewRepository.findById(id)
                .orElseThrow(() -> new CustomException(ErrorCode.REVIEW_NOT_FOUND));

        if (review.isNotOwner(userId)) {
            throw new CustomException(ErrorCode.FORBIDDEN);
        }

        review.update(request.getBookTitle(), request.getContent(), request.getRating());
        return ReviewResponse.from(review);
    }
}
```

---

## 5. 트러블슈팅

### 1. JWT 토큰 파싱 오류
**문제**: JWT 토큰 검증 중 SignatureException 발생
```
io.jsonwebtoken.security.SignatureException: JWT signature does not match locally computed signature
```

**해결 과정**:
1. JWT Secret Key 설정 확인
```yaml
jwt:
  secret: YXNkZmFzZGZhc2RmYXNkZmFzZGZhc2RmYXNkZmFzZGZhc2RmYXNkZmFzZGZhc2RmYXNkZmFzZGZhc2Rm
  expiration: 86400000 # 24시간
```
2. Base64 인코딩된 시크릿 키를 바이너리로 변환
```java
private Key getSigningKey() {
    byte[] keyBytes = Decoders.BASE64.decode(secretKey);
    return Keys.hmacShaKeyFor(keyBytes);
}
```

**결과**: JWT 토큰이 정상적으로 생성되고 검증됨

### 2. SecurityContext에서 사용자 정보 전달 이슈
**문제**: Authentication 객체에서 사용자 ID를 어떻게 안전하게 전달할 것인가

**해결 방법**:
```java
// 인증 필터에서 사용자 ID를 Details에 저장
UsernamePasswordAuthenticationToken authentication = 
    new UsernamePasswordAuthenticationToken(username, null, Collections.emptyList());
authentication.setDetails(userId);

// 서비스에서 사용자 ID 추출
private Long getCurrentUserId() {
    Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
    return (Long) authentication.getDetails();
}
```

### 3. H2 콘솔 접근 문제
**문제**: Spring Security 설정으로 인해 H2 콘솔에 접근할 수 없는 문제

**해결 과정**:
```java
.authorizeHttpRequests(auth -> auth
    .requestMatchers("/api/auth/**", "/h2-console/**").permitAll()
    // ...
)
.headers(headers -> headers
    .frameOptions(frameOptions -> frameOptions.sameOrigin()))
```

### 4. CORS 및 PreFlight 요청 처리
**문제**: 브라우저에서 OPTIONS 요청이 401 오류로 차단되는 문제

**해결 방법**:
```java
.authorizeHttpRequests(auth -> auth
    .requestMatchers(HttpMethod.OPTIONS).permitAll()
    .requestMatchers("/api/auth/**").permitAll()
    // ...
)
```

### 5. 비밀번호 검증 실패 디버깅
**문제**: 올바른 비밀번호를 입력해도 로그인이 실패하는 문제

**해결 과정**:
1. BCrypt 해시 과정 로깅 추가
2. 평문 비밀번호와 암호화된 비밀번호 매칭 테스트
```java
if (!passwordEncoder.matches(request.getPassword(), user.getPassword())) {
    log.debug("Password mismatch for user: {}", request.getUsername());
    throw new CustomException(ErrorCode.INVALID_PASSWORD);
}
```

---

## 6. 결론 및 향후 개선

### 프로젝트 성과
1. **완전한 JWT 인증 시스템 구축**: 토큰 생성부터 검증까지 전체 플로우 구현
2. **Spring Security 통합**: 최신 Spring Security 6.x를 활용한 보안 설정
3. **Stateless 아키텍처**: 세션을 사용하지 않는 확장 가능한 구조 구현
4. **권한 기반 접근 제어**: 리뷰 소유권 검증을 통한 세밀한 권한 관리

### 학습한 기술
- **JWT (JSON Web Token)**: 토큰 기반 인증의 원리와 구현
- **Spring Security**: 최신 보안 프레임워크의 필터 체인과 인증/인가 메커니즘
- **BCrypt**: 안전한 비밀번호 해싱 알고리즘 적용
- **SecurityContext**: 인증 정보의 스레드 로컬 관리

### 향후 개선 계획
1. **보안 강화**
   - Refresh Token 도입으로 토큰 갱신 메커니즘 구현
   - Rate Limiting을 통한 brute force 공격 방지
   - 비밀번호 정책 강화 (복잡도, 만료 기간 등)

2. **테스트 코드 작성**
   - SecurityConfig에 대한 통합 테스트
   - JWT 토큰 생성/검증에 대한 단위 테스트
   - 인증이 필요한 API 엔드포인트 테스트

3. **인증 시스템 확장**
   - OAuth 2.0 소셜 로그인 연동 (Google, GitHub 등)
   - Multi-Factor Authentication (MFA) 도입
   - 사용자 역할(Role) 기반 권한 관리 시스템

4. **모니터링 및 로깅**
   - 로그인 시도 및 실패에 대한 상세 로깅
   - 보안 이벤트 모니터링 시스템
   - JWT 토큰 만료 및 갱신 이벤트 추적

5. **성능 최적화**
   - JWT 토큰 캐싱 전략 도입
   - 사용자 정보 캐싱을 통한 DB 액세스 최소화
   - 비동기 로깅으로 성능 영향 최소화

이번 프로젝트로 보안에 대해 많이 배웠습니다. JWT와 Spring Security가 처음에는 어려웠는데, 하나하나 만들어보니까 이제 이해가 됐습니다. 특히 보안은 에전에 대충대충 넘어갔는데, 이번에 직접 구현해보니까 에전보다 훨씬 신경 쓰게 됐습니다. 토큰 기반 인증이 세션보다 어떤 점이 좋은지, 그리고 어떤 점을 조심해야 하는지도 알게 됐습니다.