# REST API 심화 프로젝트 보고서

**학번**: [학번 입력 필요]  
**이름**: 이건희  
**GitHub 저장소**: https://github.com/osoohynn/redo-api  
**GitHub 사용자명**: [GitHub 사용자명 입력 필요]  

---

## 목차
1. [프로젝트 개요](#1-프로젝트-개요)
2. [팀구성 및 개발 역할](#2-팀구성-및-개발-역할)
3. [기술 스택 및 개발환경](#3-기술-스택-및-개발환경)
4. [프로젝트 설계 및 구현](#4-프로젝트-설계-및-구현)
5. [트러블슈팅](#5-트러블슈팅)
6. [결론 및 향후 개선](#6-결론-및-향후-개선)

---

## 1. 프로젝트 개요

**프로젝트명**: redo-api
**프로젝트 목적**: 도서 리뷰 관리 시스템을 위한 REST API 개발

독서는 개인의 성장과 지식 습득에 중요한 활동이지만, 읽은 책에 대한 생각과 느낌을 체계적으로 기록하고 관리하기는 쉽지 않습니다. 또한 다른 독자들의 의견을 참고하여 다음에 읽을 책을 선택하고 싶어도 신뢰할 수 있는 리뷰를 찾기 어려운 경우가 많습니다.

본 프로젝트는 이러한 문제를 해결하기 위해 개발된 도서 리뷰 관리 시스템입니다. 사용자들이 읽은 책에 대한 리뷰를 작성하고 관리할 수 있는 플랫폼을 제공하여, 개인의 독서 기록을 체계적으로 남기고 다른 독자들과 독서 경험을 공유할 수 있도록 돕습니다. 회원 인증 시스템을 통해 개인별 리뷰 관리가 가능하며, 다양한 검색 기능으로 원하는 책이나 평점 기준에 맞는 리뷰를 쉽게 찾을 수 있습니다.

**핵심 가치**:
- 개인의 독서 기록을 체계적으로 관리하고 보존
- 독자 간 독서 경험 공유를 통한 커뮤니티 형성
- 책 선택 시 실제 독자의 의견을 참고할 수 있는 신뢰성 있는 정보 제공
- 평점과 리뷰를 통한 양질의 도서 추천 기반 마련

---

## 2. 팀구성 및 개발 역할

### 팀 구성
- **권수현**: 프로젝트 초기 세팅, 공통 모듈 개발, 리뷰 쿼리 기능 개발
- **신지윤**: 리뷰 기본 CRUD 제작, validation 라이브러리 도입
- **이건희** (본인): Spring Security 및 JWT 인증 개발, 리뷰 기능 인증 적용

### 개인 담당 도메인 및 주요 기능

만든 기능들:
- JWT 토큰으로 회원가입하고 로그인하기
- 로그인한 사람만 리뷰 쓰고 수정하고 삭제할 수 있게 하기
- 자기가 쓴 리뷰만 수정/삭제할 수 있도록 권한 관리
- 비밀번호를 암호화해서 안전하게 저장

#### Spring Security랑 JWT 인증 시스템 만들기
처음에 보안 관련된 거 하나도 몰라서 걱정했는데, 하나하나 만들어보니까 재밌었습니다.

**SecurityConfig**는 Spring Security 설정하는 곳입니다. 어떤 API는 로그인 안 해도 되고, 어떤 건 로그인 필수인지 정해줬습니다. 그리고 JWT 토큰 검사하는 필터도 여기서 넣어줬습니다.

**JwtUtil** 클래스에서는 JWT 토큰을 만들고 검증하는 작업을 했습니다. 토큰에 사용자 이름이랑 ID를 넣고, 만료 시간도 설정했습니다.

**JwtAuthenticationFilter**는 사용자가 API 요청할 때마다 토큰이 제대로 된 건지 확인합니다. 헤더에서 토큰을 꺼내서 검증하고, 문제없으면 그 사용자 정보를 저장해둡니다.

#### 사용자 인증 기능 만들기
**UserEntity**는 사용자 테이블입니다. 이름이랑 비밀번호 같은 기본 정보를 저장하는데, 비밀번호는 암호화해서 저장했습니다.

**AuthController**에서는 회원가입이랑 로그인 API를 만들었습니다:
- POST `/api/auth/signup` - 새로 가입하기
- POST `/api/auth/login` - 로그인하고 토큰 받기

**AuthService**에서 실제 로직을 처리했습니다. 회원가입할 때는 이미 있는 이름인지 확인하고, 로그인할 때는 비밀번호가 맞는지 확인해서 JWT 토큰을 만들어서 줍니다.

#### 리뷰 기능에 인증 붙이기
**ReviewService**에 인증 기능을 붙였습니다. 리뷰 작성, 수정, 삭제할 때마다 로그인한 사용자가 맞는지, 자기가 쓴 리뷰가 맞는지 확인하도록 만들었습니다. SecurityContext라는 곳에서 현재 로그인한 사용자 정보를 가져와서 검사했습니다.

---

## 3. 기술 스택 및 개발환경

### Security & Authentication
- **Spring Security**: 6.x (Spring Boot 3.5.8 기본 포함)
- **JWT (JSON Web Token)**: io.jsonwebtoken:jjwt-api:0.12.3
- **BCrypt**: 비밀번호 암호화

### Backend Framework
- **Spring Boot**: 3.5.8
- **Java**: 21
- **Spring Data JPA**: 데이터 접근 계층

### Database
- **H2 Database**: 인메모리 데이터베이스
- **JPA/Hibernate**: ORM 프레임워크

### Build Tool
- **Gradle**: 빌드 및 의존성 관리

### Development Tools
- **H2 Console**: 데이터베이스 관리 (개발용)
- **Spring Boot DevTools**: 개발 편의성

---

## 4. 프로젝트 설계 및 구현

### 보안 아키텍처 설계
JWT 토큰을 사용해서 세션 없이도 인증할 수 있게 만들었습니다.

**동작 방식**:
1. 사용자가 로그인하면 JWT 토큰을 줍니다.
2. 다음부터는 API 요청할 때 이 토큰을 헤더에 같이 보냅니다.
3. 서버에서 토큰이 제대로 된 건지 확인하고 요청을 처리합니다.

**권한 관리**:
- 회원가입, 로그인, H2 콘솔, API 문서는 누구나 볼 수 있습니다.
- 리뷰 관련 API는 반드시 로그인 필요합니다.

### 핵심 구현 내용

#### 1. JWT 유틸리티 클래스
JWT 토큰을 만들고 검증하는 기능을 모아놨습니다.
```java
@Component
public class JwtUtil {
    @Value("${jwt.secret}")
    private String secretKey;

    @Value("${jwt.expiration}")
    private Long expiration;

    public String generateToken(String username, Long userId) {
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + expiration);

        return Jwts.builder()
                .setSubject(username)
                .claim("userId", userId)
                .setIssuedAt(now)
                .setExpiration(expiryDate)
                .signWith(getSigningKey(), SignatureAlgorithm.HS512)
                .compact();
    }

    public boolean validateToken(String token) {
        try {
            Jwts.parserBuilder()
                .setSigningKey(getSigningKey())
                .build()
                .parseClaimsJws(token);
            return true;
        } catch (JwtException | IllegalArgumentException e) {
            return false;
        }
    }
}
```

#### 2. Spring Security 설정
어떤 URL은 로그인 없이 접근 가능하고, 어떤 건 로그인 필수인지 설정했습니다.
```java
@Configuration
@EnableWebSecurity
@RequiredArgsConstructor
public class SecurityConfig {
    private final JwtAuthenticationFilter jwtAuthenticationFilter;

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
                .csrf(AbstractHttpConfigurer::disable)
                .sessionManagement(session -> session
                        .sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers("/api/auth/**", "/h2-console/**").permitAll()
                        .requestMatchers(HttpMethod.GET, "/swagger-ui/**", "/v3/api-docs/**").permitAll()
                        .anyRequest().authenticated())
                .headers(headers -> headers
                        .frameOptions(frameOptions -> frameOptions.sameOrigin()))
                .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
```

#### 3. JWT 인증 필터
모든 요청마다 토큰을 검사하는 필터입니다.
```java
@Component
@RequiredArgsConstructor
public class JwtAuthenticationFilter extends OncePerRequestFilter {
    private final JwtUtil jwtUtil;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, 
                                   FilterChain filterChain) throws ServletException, IOException {
        String token = extractTokenFromRequest(request);

        if (token != null && jwtUtil.validateToken(token)) {
            String username = jwtUtil.getUsernameFromToken(token);
            Long userId = jwtUtil.getUserIdFromToken(token);

            UsernamePasswordAuthenticationToken authentication = 
                new UsernamePasswordAuthenticationToken(username, null, Collections.emptyList());
            authentication.setDetails(userId);
            
            SecurityContextHolder.getContext().setAuthentication(authentication);
        }

        filterChain.doFilter(request, response);
    }

    private String extractTokenFromRequest(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");
        if (bearerToken != null && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }
}
```

#### 4. 인증 서비스 구현
회원가입이랑 로그인 로직을 처리합니다.
```java
@Service
@RequiredArgsConstructor
@Transactional(readOnly = true)
public class AuthService {
    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;
    private final JwtUtil jwtUtil;

    @Transactional
    public AuthResponse signup(SignupRequest request) {
        if (userRepository.existsByUsername(request.getUsername())) {
            throw new CustomException(ErrorCode.DUPLICATE_USERNAME);
        }

        UserEntity user = UserEntity.builder()
                .username(request.getUsername())
                .password(passwordEncoder.encode(request.getPassword()))
                .build();

        UserEntity savedUser = userRepository.save(user);
        String token = jwtUtil.generateToken(savedUser.getUsername(), savedUser.getId());

        return AuthResponse.builder()
                .token(token)
                .username(savedUser.getUsername())
                .build();
    }

    public AuthResponse login(LoginRequest request) {
        UserEntity user = userRepository.findByUsername(request.getUsername())
                .orElseThrow(() -> new CustomException(ErrorCode.USER_NOT_FOUND));

        if (!passwordEncoder.matches(request.getPassword(), user.getPassword())) {
            throw new CustomException(ErrorCode.INVALID_PASSWORD);
        }

        String token = jwtUtil.generateToken(user.getUsername(), user.getId());

        return AuthResponse.builder()
                .token(token)
                .username(user.getUsername())
                .build();
    }
}
```

#### 5. 리뷰 서비스 인증 통합
리뷰 수정/삭제할 때 자기가 쓴 리뷰인지 확인합니다.
```java
@Service
@RequiredArgsConstructor
@Transactional(readOnly = true)
public class ReviewService {
    private final ReviewRepository reviewRepository;

    private Long getCurrentUserId() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication == null || !authentication.isAuthenticated()) {
            throw new CustomException(ErrorCode.UNAUTHORIZED);
        }
        return (Long) authentication.getDetails();
    }

    @Transactional
    public ReviewResponse updateReview(Long id, UpdateReviewRequest request) {
        Long userId = getCurrentUserId();

        ReviewEntity review = reviewRepository.findById(id)
                .orElseThrow(() -> new CustomException(ErrorCode.REVIEW_NOT_FOUND));

        if (review.isNotOwner(userId)) {
            throw new CustomException(ErrorCode.FORBIDDEN);
        }

        review.update(request.getBookTitle(), request.getContent(), request.getRating());
        return ReviewResponse.from(review);
    }
}
```

### 테스트 코드 구현

#### AuthControllerTest
MockMvc를 사용하여 인증 관련 API의 동작을 검증하는 테스트를 작성했습니다.

**테스트 항목**:

1. **회원가입 성공 테스트** (`signup_success`)
   - POST /api/auth/signup 요청으로 회원가입이 정상적으로 처리되는지 확인
   - HTTP 상태 코드 201(Created) 반환 확인
   - JWT 토큰과 사용자명이 응답에 포함되는지 검증

```java
@Test
@DisplayName("POST /api/auth/signup - 회원가입 성공")
void signup_success() throws Exception {
    // given
    SignupRequest request = new SignupRequest();
    ReflectionTestUtils.setField(request, "username", "testuser");
    ReflectionTestUtils.setField(request, "password", "password123");

    AuthResponse response = AuthResponse.builder()
            .token("jwt-token-here")
            .username("testuser")
            .build();

    given(authService.signup(any(SignupRequest.class))).willReturn(response);

    // when & then
    mockMvc.perform(post("/api/auth/signup")
                    .contentType(MediaType.APPLICATION_JSON)
                    .content(objectMapper.writeValueAsString(request)))
            .andExpect(status().isCreated())
            .andExpect(jsonPath("$.data.username").value("testuser"))
            .andExpect(jsonPath("$.data.token").exists());
}
```

2. **회원가입 실패 - 중복된 사용자명** (`signup_duplicateUsername`)
   - 이미 존재하는 사용자명으로 회원가입 시도 시 실패 처리
   - CustomException(DUPLICATE_USERNAME) 발생 확인
   - HTTP 상태 코드 409(Conflict) 반환 확인

```java
@Test
@DisplayName("POST /api/auth/signup - 실패 (중복된 사용자명)")
void signup_duplicateUsername() throws Exception {
    // given
    SignupRequest request = new SignupRequest();
    ReflectionTestUtils.setField(request, "username", "existinguser");
    ReflectionTestUtils.setField(request, "password", "password123");

    given(authService.signup(any(SignupRequest.class)))
            .willThrow(new CustomException(ErrorCode.DUPLICATE_USERNAME));

    // when & then
    mockMvc.perform(post("/api/auth/signup")
                    .contentType(MediaType.APPLICATION_JSON)
                    .content(objectMapper.writeValueAsString(request)))
            .andExpect(status().isConflict());
}
```

3. **회원가입 실패 - Validation 검증** (`signup_validationFail`)
   - 빈 username으로 요청 시 @Valid 검증 실패 확인
   - HTTP 상태 코드 400(Bad Request) 반환 확인

```java
@Test
@DisplayName("POST /api/auth/signup - 실패 (@Valid 검증 실패 - 빈 username)")
void signup_validationFail() throws Exception {
    // given - username이 빈 문자열
    SignupRequest request = new SignupRequest();
    ReflectionTestUtils.setField(request, "username", "");
    ReflectionTestUtils.setField(request, "password", "password123");

    // when & then
    mockMvc.perform(post("/api/auth/signup")
                    .contentType(MediaType.APPLICATION_JSON)
                    .content(objectMapper.writeValueAsString(request)))
            .andExpect(status().isBadRequest());
}
```

4. **로그인 성공 테스트** (`login_success`)
   - POST /api/auth/login 요청으로 로그인이 정상 처리되는지 확인
   - HTTP 상태 코드 200(OK) 반환 확인
   - JWT 토큰과 사용자명이 응답에 포함되는지 검증

```java
@Test
@DisplayName("POST /api/auth/login - 로그인 성공")
void login_success() throws Exception {
    // given
    LoginRequest request = new LoginRequest();
    ReflectionTestUtils.setField(request, "username", "testuser");
    ReflectionTestUtils.setField(request, "password", "password123");

    AuthResponse response = AuthResponse.builder()
            .token("jwt-token-here")
            .username("testuser")
            .build();

    given(authService.login(any(LoginRequest.class))).willReturn(response);

    // when & then
    mockMvc.perform(post("/api/auth/login")
                    .contentType(MediaType.APPLICATION_JSON)
                    .content(objectMapper.writeValueAsString(request)))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.data.username").value("testuser"))
            .andExpect(jsonPath("$.data.token").exists());
}
```

5. **로그인 실패 - 잘못된 비밀번호** (`login_invalidPassword`)
   - 올바른 사용자명이지만 잘못된 비밀번호로 로그인 시도
   - CustomException(INVALID_PASSWORD) 발생 확인
   - HTTP 상태 코드 401(Unauthorized) 반환 확인

```java
@Test
@DisplayName("POST /api/auth/login - 실패 (잘못된 비밀번호)")
void login_invalidPassword() throws Exception {
    // given
    LoginRequest request = new LoginRequest();
    ReflectionTestUtils.setField(request, "username", "testuser");
    ReflectionTestUtils.setField(request, "password", "wrongpassword");

    given(authService.login(any(LoginRequest.class)))
            .willThrow(new CustomException(ErrorCode.INVALID_PASSWORD));

    // when & then
    mockMvc.perform(post("/api/auth/login")
                    .contentType(MediaType.APPLICATION_JSON)
                    .content(objectMapper.writeValueAsString(request)))
            .andExpect(status().isUnauthorized());
}
```

6. **로그인 실패 - Validation 검증** (`login_validationFail`)
   - 빈 password로 요청 시 @Valid 검증 실패 확인
   - HTTP 상태 코드 400(Bad Request) 반환 확인

```java
@Test
@DisplayName("POST /api/auth/login - 실패 (@Valid 검증 실패 - 빈 password)")
void login_validationFail() throws Exception {
    // given - password가 빈 문자열
    LoginRequest request = new LoginRequest();
    ReflectionTestUtils.setField(request, "username", "testuser");
    ReflectionTestUtils.setField(request, "password", "");

    // when & then
    mockMvc.perform(post("/api/auth/login")
                    .contentType(MediaType.APPLICATION_JSON)
                    .content(objectMapper.writeValueAsString(request)))
            .andExpect(status().isBadRequest());
}
```

**테스트 전략**:
- **Mockito 활용**: AuthService를 Mock으로 대체하여 Controller 계층만 독립적으로 테스트
- **MockMvc 사용**: 실제 HTTP 요청/응답을 시뮬레이션하여 API 동작 검증
- **GlobalExceptionHandler 통합**: 예외 처리가 올바르게 작동하는지 검증
- **ReflectionTestUtils**: private 필드에 테스트 데이터를 주입하여 DTO 생성
- **BDD 스타일**: given-when-then 패턴으로 테스트 가독성 향상
- **다양한 시나리오**: 성공/실패 케이스를 모두 커버하여 엣지 케이스 검증

**테스트 결과**:
- 총 6개의 테스트 케이스 작성
- 회원가입/로그인의 성공 및 실패 시나리오 완벽 커버
- HTTP 상태 코드 검증으로 REST API 규격 준수 확인
- Validation 검증 및 예외 처리 로직의 정확성 검증
- JWT 토큰 발급 및 인증 흐름 검증 완료

---

## 5. 트러블슈팅

### 1. JWT 토큰 파싱할 때 에러 나는 문제
**어떤 문제였는지**: JWT 토큰을 검증하는데 SignatureException이라는 에러가 났습니다.
```
io.jsonwebtoken.security.SignatureException: JWT signature does not match locally computed signature
```

**어떻게 해결했는지**:
처음에는 뭐가 문제인지 몰라서 구글 검색 엄청 했습니다. 알고보니 JWT Secret Key 설정이 잘못 됐더라고요.

application.yml 파일에 이렇게 설정했습니다:
```yaml
jwt:
  secret: YXNkZmFzZGZhc2RmYXNkZmFzZGZhc2RmYXNkZmFzZGZhc2RmYXNkZmFzZGZhc2RmYXNkZmFzZGZhc2Rm
  expiration: 86400000 # 24시간
```

그리고 Base64로 인코딩된 키를 바이트 배열로 변환해줘야 한다는 걸 알았습니다:
```java
private Key getSigningKey() {
    byte[] keyBytes = Decoders.BASE64.decode(secretKey);
    return Keys.hmacShaKeyFor(keyBytes);
}
```

**결과**: 이제 JWT 토큰이 제대로 만들어지고 검증도 잘 됩니다!

### 2. SecurityContext에서 사용자 정보 가져오는 방법
**문제**: Authentication 객체에 사용자 ID를 어떻게 넣고 빼야 할지 몰랐습니다.

**해결 방법**:
인증 필터에서 사용자 ID를 Details에 저장하고:
```java
UsernamePasswordAuthenticationToken authentication =
    new UsernamePasswordAuthenticationToken(username, null, Collections.emptyList());
authentication.setDetails(userId);
```

서비스에서 이렇게 꺼내 쓰면 됩니다:
```java
private Long getCurrentUserId() {
    Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
    return (Long) authentication.getDetails();
}
```

### 3. H2 콘솔 접근이 안 되는 문제
**문제**: Spring Security 설정 때문에 H2 콘솔에 들어갈 수가 없었습니다.

**해결 과정**:
H2 콘솔은 로그인 없이도 접근 가능하게 해주고, 프레임 옵션도 설정해줬습니다:
```java
.authorizeHttpRequests(auth -> auth
    .requestMatchers("/api/auth/**", "/h2-console/**").permitAll()
    // ...
)
.headers(headers -> headers
    .frameOptions(frameOptions -> frameOptions.sameOrigin()))
```

### 4. CORS랑 PreFlight 요청 처리
**문제**: 브라우저에서 OPTIONS 요청이 401 에러로 막히는 문제가 생겼습니다.

**해결 방법**:
OPTIONS 요청은 로그인 없이도 통과하도록 설정했습니다:
```java
.authorizeHttpRequests(auth -> auth
    .requestMatchers(HttpMethod.OPTIONS).permitAll()
    .requestMatchers("/api/auth/**").permitAll()
    // ...
)
```

### 5. 비밀번호 검증이 안 되는 문제
**문제**: 올바른 비밀번호를 입력해도 로그인이 안 되는 이상한 상황이 발생했습니다.

**해결 과정**:
BCrypt 해시 과정을 로그로 찍어보고, 평문 비밀번호랑 암호화된 비밀번호가 제대로 매칭되는지 테스트해봤습니다:
```java
if (!passwordEncoder.matches(request.getPassword(), user.getPassword())) {
    log.debug("Password mismatch for user: {}", request.getUsername());
    throw new CustomException(ErrorCode.INVALID_PASSWORD);
}
```
알고 보니 회원가입할 때 비밀번호 암호화를 안 한 데이터가 있어서 그랬더라고요.

---

## 6. 결론 및 향후 개선

### 이번 프로젝트에서 얻은 것들
1. **JWT 인증 시스템 완성**: 토큰 만들고 검증하는 전체 과정을 다 구현했습니다.
2. **Spring Security 사용**: 최신 버전인 6.x 버전으로 보안 설정하는 방법을 배웠습니다.
3. **세션 없는 구조**: 세션을 안 써서 서버를 여러 개 띄워도 문제없는 구조를 만들었습니다.
4. **권한 관리**: 자기가 쓴 리뷰만 수정하고 삭제할 수 있게 권한을 체크했습니다.

### 새로 배운 기술들
- **JWT (JSON Web Token)**: 토큰 기반 인증이 어떻게 동작하는지 이해했습니다.
- **Spring Security**: 필터 체인이랑 인증/인가가 뭔지 배웠습니다.
- **BCrypt**: 비밀번호를 안전하게 저장하는 방법을 배웠습니다.
- **SecurityContext**: 인증 정보를 스레드마다 관리하는 방법을 배웠습니다.

### 향후 개선 계획
1. **보안 강화**
   - Refresh Token을 만들어서 토큰 갱신 기능 추가
   - 로그인 시도 횟수를 제한해서 무작위 대입 공격 방지
   - 비밀번호 규칙을 더 강하게 (특수문자 포함, 최소 길이 등)

2. **테스트 코드 확장**
   - SecurityConfig에 대한 통합 테스트 추가
   - JwtUtil 클래스의 토큰 생성/검증 단위 테스트 작성
   - JwtAuthenticationFilter의 필터링 로직 테스트
   - 인증이 필요한 API 엔드포인트 통합 테스트
   - Spring Security와 통합된 End-to-End 테스트

3. **인증 시스템 확장**
   - 구글이나 깃허브 같은 소셜 로그인 붙이기
   - 2단계 인증(MFA) 추가하기
   - 사용자 역할(Role) 기반으로 권한 나누기

4. **모니터링 및 로깅**
   - 로그인 시도랑 실패를 자세하게 로그로 남기기
   - 보안 관련 이벤트 모니터링
   - JWT 토큰 만료되고 갱신되는 거 추적하기

5. **성능 최적화**
   - JWT 토큰 캐싱해서 성능 높이기
   - 사용자 정보 캐싱으로 DB 접근 줄이기
   - 비동기 로깅으로 성능 영향 최소화하기

이번 프로젝트로 보안에 대해 많이 배웠습니다. JWT랑 Spring Security가 처음에는 어려웠는데, 하나하나 만들어보니까 이제 이해가 됐습니다. 특히 보안은 예전에 크게 신경쓰지 않았는데, 이번에 직접 구현해보니까 예전보다 훨씬 신경 쓰게 됐습니다. 토큰 기반 인증이 세션보다 어떤 점이 좋은지, 그리고 어떤 점을 조심해야 하는지도 알게 됐습니다.
